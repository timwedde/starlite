{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".cls-1 { fill: #1d2433; } .cls-2 { fill: #ffae57; } .cls-3 { fill: #ffd580; } .cls-4 { fill: #d6dbe1; } .cls-5 { fill: #fff; } Starlite is a light, opinionated and flexible ASGI API framework built on top of pydantic and Starlette . The Starlite framework is pluggable and ships with dependency injection , authentication , OpenAPI specifications-generation \u2013 among other common API-framework components such as middleware and guards . Installation Starlite can be installed with any package manager of your choice: pip install starlite poetry add starlite pipenv install starlite Minimal Example Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 Alternatively, you can use a dataclass \u2013 either from dataclasses or from pydantic: my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> User : ... When instantiating your app, import your controller into your application's entry-point and pass it to Starlite: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run your application , use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload About the Starlite Project This project builds on top the Starlette ASGI toolkit and pydantic modelling to create a higher-order opinionated framework. The idea to use these two libraries as a basis is of course not new - it was first done in FastAPI, which in this regard (and some others) was a source of inspiration for this framework. Nonetheless, Starlite is not FastAPI - it has a different design, different project goals and a completely different codebase. The goal of this project is to become a community-driven project. That is, not to have a single \"owner\" but rather a core team of maintainers that leads the project, as well as community contributors. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. As such, the design of the API breaks from the Starlette design and instead offers an opinionated alternative. Finally, Python OOP is extremely powerful and versatile. While still allowing for function-based endpoints , Starlite seeks to build on this by placing class-based controllers at its core. Continue reading","title":"Overview"},{"location":"#installation","text":"Starlite can be installed with any package manager of your choice: pip install starlite poetry add starlite pipenv install starlite","title":"Installation"},{"location":"#minimal-example","text":"Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 Alternatively, you can use a dataclass \u2013 either from dataclasses or from pydantic: my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> User : ... When instantiating your app, import your controller into your application's entry-point and pass it to Starlite: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run your application , use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload","title":"Minimal Example"},{"location":"#about-the-starlite-project","text":"This project builds on top the Starlette ASGI toolkit and pydantic modelling to create a higher-order opinionated framework. The idea to use these two libraries as a basis is of course not new - it was first done in FastAPI, which in this regard (and some others) was a source of inspiration for this framework. Nonetheless, Starlite is not FastAPI - it has a different design, different project goals and a completely different codebase. The goal of this project is to become a community-driven project. That is, not to have a single \"owner\" but rather a core team of maintainers that leads the project, as well as community contributors. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. As such, the design of the API breaks from the Starlette design and instead offers an opinionated alternative. Finally, Python OOP is extremely powerful and versatile. While still allowing for function-based endpoints , Starlite seeks to build on this by placing class-based controllers at its core. Continue reading","title":"About the Starlite Project"},{"location":"contributing/","text":"Contributing To contribute code changes or update the documentation, please follow these steps: Fork the upstream repository and clone the fork locally. Install poetry , and install the project's dependencies with poetry install Install pre-commit by running pre-commit install Make whatever changes and additions you wish and commit these - please try to keep your commit history clean. Create a pull request to the main repository with an explanation of your changes Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.","title":"Contributing"},{"location":"contributing/#contributing","text":"To contribute code changes or update the documentation, please follow these steps: Fork the upstream repository and clone the fork locally. Install poetry , and install the project's dependencies with poetry install Install pre-commit by running pre-commit install Make whatever changes and additions you wish and commit these - please try to keep your commit history clean. Create a pull request to the main repository with an explanation of your changes Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.","title":"Contributing"},{"location":"license/","text":"License MIT License Copyright \u00a9 2021-2022 Na'aman Hirschfeld Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2021-2022 Na'aman Hirschfeld Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"migration/","text":"Migration to Starlite Migrating from either Starlette or FastAPI to Starlite is rather uncomplicated, because the frameworks are for the most part inter-compatible . So what does need to be changed? LifeCycle If you use the Starlette/FastAPI lifecycle kwarg with an AsyncContextManager to bootstrap your application, you will need to convert it to use the on_startup and on_shutdown hooks . Otherwise, using lifecycle management is identical. Routing Decorators Starlite does not include any decorator as part of the Router or Starlite instances. All routes have to be declared using route handlers \u2013 in standalone functions or Controller methods. You then have to register them with the app, either by first registering them on a router and then registering the router on the app , or by registering them directly on the app . See the registering routes part of the documentation for details. Routing Classes As discussed in the relation to starlette routing section of the documentation, Starlite does not extend the Starlette routing classes and instead implements its own versions of these. You will need to use the Starlite Router classes instead of their equivalents from the other frameworks. There are some differences from the Starlite class to those from the other frameworks: The Starlite version is not an ASGI app , the only ASGI app is the Starlite app and any middlewares you pass to it. The Starlite version does not include decorators , instead you have to use route handlers . The Starlite version does not support lifecycle hooks, instead you have to handle all of your lifecycle management in the app layer. If you use the Starlette Route instances directly, you will need to replace these with route handlers . Important The Starlette Mount class is replaced by the Starlite Router . The Host class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different microservices rather than use this kind of routing Dependency Injection The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depend class. In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the Provide class. Authentication FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending the Starlite AbstractAuthenticationMiddleware class . Third Party Packages Third party packages created for Starlette and FastAPI should be generally compatible with Starlite. The only exceptions are for packages that use the FastAPI dependency injection system as a basis - these will not work as such.","title":"Migration to Starlite"},{"location":"migration/#migration-to-starlite","text":"Migrating from either Starlette or FastAPI to Starlite is rather uncomplicated, because the frameworks are for the most part inter-compatible . So what does need to be changed?","title":"Migration to Starlite"},{"location":"migration/#lifecycle","text":"If you use the Starlette/FastAPI lifecycle kwarg with an AsyncContextManager to bootstrap your application, you will need to convert it to use the on_startup and on_shutdown hooks . Otherwise, using lifecycle management is identical.","title":"LifeCycle"},{"location":"migration/#routing-decorators","text":"Starlite does not include any decorator as part of the Router or Starlite instances. All routes have to be declared using route handlers \u2013 in standalone functions or Controller methods. You then have to register them with the app, either by first registering them on a router and then registering the router on the app , or by registering them directly on the app . See the registering routes part of the documentation for details.","title":"Routing Decorators"},{"location":"migration/#routing-classes","text":"As discussed in the relation to starlette routing section of the documentation, Starlite does not extend the Starlette routing classes and instead implements its own versions of these. You will need to use the Starlite Router classes instead of their equivalents from the other frameworks. There are some differences from the Starlite class to those from the other frameworks: The Starlite version is not an ASGI app , the only ASGI app is the Starlite app and any middlewares you pass to it. The Starlite version does not include decorators , instead you have to use route handlers . The Starlite version does not support lifecycle hooks, instead you have to handle all of your lifecycle management in the app layer. If you use the Starlette Route instances directly, you will need to replace these with route handlers . Important The Starlette Mount class is replaced by the Starlite Router . The Host class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different microservices rather than use this kind of routing","title":"Routing Classes"},{"location":"migration/#dependency-injection","text":"The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depend class. In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the Provide class.","title":"Dependency Injection"},{"location":"migration/#authentication","text":"FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending the Starlite AbstractAuthenticationMiddleware class .","title":"Authentication"},{"location":"migration/#third-party-packages","text":"Third party packages created for Starlette and FastAPI should be generally compatible with Starlite. The only exceptions are for packages that use the FastAPI dependency injection system as a basis - these will not work as such.","title":"Third Party Packages"},{"location":"usage/0-the-starlite-app/","text":"The Starlite App At the root of every Starlite application is an instance of the Starlite class or a subclass of it. Typically, this code will be placed in a file called main.py at the project's root directory . Creating an app is straightforward \u2013 the only required kwarg is a list of Controllers , Routers or Route Handlers : my_app/main.py from starlite import Starlite , get @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) The app instance is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. See registering routes for full details. You can additionally pass the following kwargs to the Starlite constructor: allowed_hosts : A list of allowed hosts. If set this enables the AllowedHostsMiddleware . See middleware . cors_config : An instance of starlite.config.CORSConfig . If set this enables the CORSMiddleware . See middleware . debug : A boolean flag toggling debug mode on and off, if True, 404 errors will be rendered as HTML with a stack trace. This option should not be used in production. Default to False . dependencies : A dictionary mapping dependency providers. See dependency-injection . exception_handlers : A dictionary mapping exceptions or exception codes to handler functions. See exception-handlers . guards : A list of callables. See guards . middleware : A list of classes adhering to the Starlite MiddlewareProtocol , instance of the Starlette Middleware class, or subclasses of the Starlette BaseHTTPMiddleware class. See middleware . on_shutdown : A list of callables that are called during the application shutdown. See startup-and-shutdown . on_startup : A list of callables that are called during the application startup. See startup-and-shutdown . openapi_config : An instance of starlite.config.OpenAPIConfig . Defaults to the baseline config. See open-api . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . before_request : a sync or async function to execute before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : a sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object. static_files_config : an instance or list of starlite.config.StaticFilesConfig . See static files . Startup and Shutdown You can pass a list of callables, sync and/or async , using the on_startup / on_shutdown kwargs. These callables will be called when the ASGI server (uvicorn, dafne etc.) emits the respective \"startup\" or \"shutdown\" event. A classic use case for this is database connectivity . Often you will want to establish the connection once \u2013 on application startup, and then close the connection on shutdown. For example, lets assume we create a connection to a Postgres DB using the async engine from SQLAlchemy , and we therefore opt to create two functions , one to get or establish the connection , and another to close it: my_app/postgres.py from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from app.config import settings state : dict [ str , AsyncEngine ] = {} def get_postgres_connection () -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" if not state . get ( \"postgres_connection\" ): state [ \"postgres_connection\" ] = create_async_engine ( settings . DATABASE_URI ) return cast ( AsyncEngine , state . get ( \"postgres_connection\" )) async def close_postgres_connection () -> None : \"\"\"Closes the postgres connection stored in the given State object\"\"\" engine = state . get ( \"postgres_connection\" ) if engine : await cast ( AsyncEngine , engine ) . dispose () We now simply need to pass these to the Starlite init method to ensure these are called correctly: my_app/main.py from starlite import Starlite from my_app.postgres import get_postgres_connection , close_postgres_connection app = Starlite ( on_startup = [ get_postgres_connection ], on_shutdown = [ close_postgres_connection ]) Using Application State Callables passed to the on_startup / on_shutdown hooks can receive either no arguments, or a single argument for the application state . The application state is available on the app instance as the app.state attribute and it is an instance of the class starlite.datastructures.State , which inherits from starlette.datastructures.State . Let's rewrite the previous examples to use the application state: my_app/postgres.py from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite.datastructures import State from app.config import settings def get_postgres_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" if not hasattr ( state , \"postgres_connection\" ): state . postgres_connection = create_async_engine ( settings . DATABASE_URI ) return cast ( AsyncEngine , state . postgres_connection ) async def close_postgres_connection ( state : State ) -> None : \"\"\"Closes the postgres connection stored in the given State object\"\"\" if hasattr ( state , \"postgres_connection\" ): await cast ( AsyncEngine , state . postgres_connection ) . dispose () The advantage of following this pattern is that the application state can be injected into dependencies and route handlers. Regarding this see handler function kwargs . Logging Another common requirement for an application startup is logging . Although Starlite does not configure logging out-of-the box , it does come with a convenience pydantic model called LoggingConfig , which you can use like so: my_app/main.py from starlite import Starlite , LoggingConfig my_app_logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], } } ) app = Starlite ( on_startup = [ my_app_logging_config . configure ]) LoggingConfig is a convenience wrapper around the standard library's DictConfig options, which can be rather confusing. It pre-configures logging to use the QueueHandler , which is non-blocking and recommended for async applications. In the above we defined a logger for the \"my_app\" namespace with a level of \"INFO\", i.e. only messages of INFO severity or above will be logged by it, using the LoggingConfig default console handler, which will emit logging messages to * sys.stderr_ using the QueueHandler . You do not need to use LoggingConfig to set up logging. This is completely decoupled from Starlite itself, and you are free to use whatever solution you want for this (e.g. loguru ). Still, if you do set up logging - then the on_startup hook is a good place to do this. Exceptions The Starlite HTTPException class can receive 3 optional kwargs: detail : The error message. Defaults to the \"phrase\" of the status code using http.HttpStatus . status_code : A valid HTTP error status code (4xx or 5xx range). Defaults to 500. extra : A dictionary of arbitrary values. This dictionary will be serialized and sent as part of the response. Defaults to None . Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503. Exception Handling Starlite handles all errors by default by transforming them into JSON responses . If the errors are instances of either the starlette.exceptions.HTTPException or the starlite.exceptions.HTTPException , the responses will include the appropriate status_code . Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary \u2013 mapping either error codes, or exception classes, to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, ) Static Files Static files are files served by the app from predefined locations. To configure static file serving, either pass an instance of starlite.config.StaticFilesConfig or a list thereof to the Starlite constructor using the static_files_config kwarg. For example, lets say our Starlite app is going to serve regular files from the \"my_app/static\" folder and html documents from the \"my_app/html\" folder, and we would like to serve the static files on the \"/files\" path, and the html files on the \"/html\" path: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/files\" ), StaticFilesConfig ( directories = [ \"html\" ], path = \"/html\" , html_mode = True ), ], ) Matching is done based on filename: Assumed we have a request that is trying to retrieve the path /files/file.txt , the directory for the base path /files will be searched for the file file.txt . If it is found, the file will be sent over, otherwise a 404 response will be sent. If html_mode is enabled and no specific file is requested, the application will fallback to serving index.html . If no file is found the application will look for a 404.html file in order to render a response, otherwise a 404 NotFoundException will be returned.","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/#the-starlite-app","text":"At the root of every Starlite application is an instance of the Starlite class or a subclass of it. Typically, this code will be placed in a file called main.py at the project's root directory . Creating an app is straightforward \u2013 the only required kwarg is a list of Controllers , Routers or Route Handlers : my_app/main.py from starlite import Starlite , get @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) The app instance is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. See registering routes for full details. You can additionally pass the following kwargs to the Starlite constructor: allowed_hosts : A list of allowed hosts. If set this enables the AllowedHostsMiddleware . See middleware . cors_config : An instance of starlite.config.CORSConfig . If set this enables the CORSMiddleware . See middleware . debug : A boolean flag toggling debug mode on and off, if True, 404 errors will be rendered as HTML with a stack trace. This option should not be used in production. Default to False . dependencies : A dictionary mapping dependency providers. See dependency-injection . exception_handlers : A dictionary mapping exceptions or exception codes to handler functions. See exception-handlers . guards : A list of callables. See guards . middleware : A list of classes adhering to the Starlite MiddlewareProtocol , instance of the Starlette Middleware class, or subclasses of the Starlette BaseHTTPMiddleware class. See middleware . on_shutdown : A list of callables that are called during the application shutdown. See startup-and-shutdown . on_startup : A list of callables that are called during the application startup. See startup-and-shutdown . openapi_config : An instance of starlite.config.OpenAPIConfig . Defaults to the baseline config. See open-api . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . before_request : a sync or async function to execute before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : a sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object. static_files_config : an instance or list of starlite.config.StaticFilesConfig . See static files .","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/#startup-and-shutdown","text":"You can pass a list of callables, sync and/or async , using the on_startup / on_shutdown kwargs. These callables will be called when the ASGI server (uvicorn, dafne etc.) emits the respective \"startup\" or \"shutdown\" event. A classic use case for this is database connectivity . Often you will want to establish the connection once \u2013 on application startup, and then close the connection on shutdown. For example, lets assume we create a connection to a Postgres DB using the async engine from SQLAlchemy , and we therefore opt to create two functions , one to get or establish the connection , and another to close it: my_app/postgres.py from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from app.config import settings state : dict [ str , AsyncEngine ] = {} def get_postgres_connection () -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" if not state . get ( \"postgres_connection\" ): state [ \"postgres_connection\" ] = create_async_engine ( settings . DATABASE_URI ) return cast ( AsyncEngine , state . get ( \"postgres_connection\" )) async def close_postgres_connection () -> None : \"\"\"Closes the postgres connection stored in the given State object\"\"\" engine = state . get ( \"postgres_connection\" ) if engine : await cast ( AsyncEngine , engine ) . dispose () We now simply need to pass these to the Starlite init method to ensure these are called correctly: my_app/main.py from starlite import Starlite from my_app.postgres import get_postgres_connection , close_postgres_connection app = Starlite ( on_startup = [ get_postgres_connection ], on_shutdown = [ close_postgres_connection ])","title":"Startup and Shutdown"},{"location":"usage/0-the-starlite-app/#using-application-state","text":"Callables passed to the on_startup / on_shutdown hooks can receive either no arguments, or a single argument for the application state . The application state is available on the app instance as the app.state attribute and it is an instance of the class starlite.datastructures.State , which inherits from starlette.datastructures.State . Let's rewrite the previous examples to use the application state: my_app/postgres.py from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite.datastructures import State from app.config import settings def get_postgres_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" if not hasattr ( state , \"postgres_connection\" ): state . postgres_connection = create_async_engine ( settings . DATABASE_URI ) return cast ( AsyncEngine , state . postgres_connection ) async def close_postgres_connection ( state : State ) -> None : \"\"\"Closes the postgres connection stored in the given State object\"\"\" if hasattr ( state , \"postgres_connection\" ): await cast ( AsyncEngine , state . postgres_connection ) . dispose () The advantage of following this pattern is that the application state can be injected into dependencies and route handlers. Regarding this see handler function kwargs .","title":"Using Application State"},{"location":"usage/0-the-starlite-app/#logging","text":"Another common requirement for an application startup is logging . Although Starlite does not configure logging out-of-the box , it does come with a convenience pydantic model called LoggingConfig , which you can use like so: my_app/main.py from starlite import Starlite , LoggingConfig my_app_logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], } } ) app = Starlite ( on_startup = [ my_app_logging_config . configure ]) LoggingConfig is a convenience wrapper around the standard library's DictConfig options, which can be rather confusing. It pre-configures logging to use the QueueHandler , which is non-blocking and recommended for async applications. In the above we defined a logger for the \"my_app\" namespace with a level of \"INFO\", i.e. only messages of INFO severity or above will be logged by it, using the LoggingConfig default console handler, which will emit logging messages to * sys.stderr_ using the QueueHandler . You do not need to use LoggingConfig to set up logging. This is completely decoupled from Starlite itself, and you are free to use whatever solution you want for this (e.g. loguru ). Still, if you do set up logging - then the on_startup hook is a good place to do this.","title":"Logging"},{"location":"usage/0-the-starlite-app/#exceptions","text":"The Starlite HTTPException class can receive 3 optional kwargs: detail : The error message. Defaults to the \"phrase\" of the status code using http.HttpStatus . status_code : A valid HTTP error status code (4xx or 5xx range). Defaults to 500. extra : A dictionary of arbitrary values. This dictionary will be serialized and sent as part of the response. Defaults to None . Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503.","title":"Exceptions"},{"location":"usage/0-the-starlite-app/#exception-handling","text":"Starlite handles all errors by default by transforming them into JSON responses . If the errors are instances of either the starlette.exceptions.HTTPException or the starlite.exceptions.HTTPException , the responses will include the appropriate status_code . Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary \u2013 mapping either error codes, or exception classes, to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, )","title":"Exception Handling"},{"location":"usage/0-the-starlite-app/#static-files","text":"Static files are files served by the app from predefined locations. To configure static file serving, either pass an instance of starlite.config.StaticFilesConfig or a list thereof to the Starlite constructor using the static_files_config kwarg. For example, lets say our Starlite app is going to serve regular files from the \"my_app/static\" folder and html documents from the \"my_app/html\" folder, and we would like to serve the static files on the \"/files\" path, and the html files on the \"/html\" path: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/files\" ), StaticFilesConfig ( directories = [ \"html\" ], path = \"/html\" , html_mode = True ), ], ) Matching is done based on filename: Assumed we have a request that is trying to retrieve the path /files/file.txt , the directory for the base path /files will be searched for the file file.txt . If it is found, the file will be sent over, otherwise a 404 response will be sent. If html_mode is enabled and no specific file is requested, the application will fallback to serving index.html . If no file is found the application will look for a 404.html file in order to render a response, otherwise a 404 NotFoundException will be returned.","title":"Static Files"},{"location":"usage/1-routers-and-controllers/","text":"Routers and Controllers In most cases an API is composed of multiple endpoints, often with different sub-paths. Starlite offers two class components that make this simple to achieve - Router and Controller . Controllers Controllers are subclasses of the Starlite Controller class that are used to organize endpoints under a specific sub-path. You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The distinct advantage of using controllers is that they allow both code sharing using OOP techniques and make the code better organized by promoting concern based code splitting. my_app/orders/controllers/user_order_controller.py from pydantic import UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial from my_app.orders.models import UserOrder class UserOrderController ( Controller ): path = \"/user\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ]) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> UserOrder : ... The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller, while retrieve_user_order has the path /user/{order_id:uuid}\" . Note You do not have to declare a path variable, yet if the path variable is missing or is an empty string, it will default to the root path of \"/\". Aside from the path class variable, you can also set the following optional class variables: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . before_request : a sync or async function to execute before a Request is passed to a route handler (method) on the controller. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : a sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object. Routers my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) The Starlite Router class is used to organize sub-paths under a common namespace. In the above, it registers two different controllers, and each controller's respective path is combined with the router's path. Assuming that the UserOrderController defines a path of \"/user\" and PartnerOrderController defines a path of \" /partner\", their paths will be \"/orders/user\" and \"orders/partner\" respectively. Aside from path and route_handlers which are required kwargs, you can also pass the following kwargs to Router: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . before_request : a sync or async function to execute before a Request is passed to a route handler (function or controller method) on the router. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : a sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object. Registering Routes At the root of every Starlite application there is an instance of Starlite, on which the root level controllers, routers and/or router-handlers are registered, for example: my_app/main.py from starlite import get , Starlite from users import UserController from orders import order_router @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check , UserController , order_router ]) The root level components registered on the app have whatever path is defined on them without anything appended to it. Thus, the health_check function above is available on \"/\" and the methods of UserController are available on \" /users\". To handle more complex path schemas you should use routers, which can register Controllers, individual functions but also other routers: my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) Once order_router is registered on base_router , the controllers registered on it will be respectively available on: \"/base/orders/user\" and \"/base/order/partner\" respectively. Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised. Registering Controllers Multiple Times Unlike routers, which can only be registered once, the same controller can be registered on different routers: my_app/users/router.py from starlite import Router from my_app.user.controllers import UserController internal_router = Router ( path = \"/internal\" , route_handlers = [ UserController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ UserController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ UserController ]) In the above, the same UserController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore , in the above example, three different instance of UserController will be created, each mounted on a different sub-path, e.g. \"/internal/users\", \"/partner/users\" and \"/consumer/users\". Registering Standalone Route Handlers Multiple Times You can also register standalone route handler handlers multiple times: my_app/users/router.py from starlite import Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) This is possible because the route handler is copied when registered. Thus, each router has its own unique instance of the route handler rather than the same one. Path behaviour is identical to controllers, namely, the route handler function will be accessible in the following paths: \"/internal/handler\", \"/partner/handler\" and \"/consumer/handler\". Relation to Starlette Routing Although Starlite uses the Starlette ASGI toolkit, Starlite does not extend or use the Starlette routing system as is. That is to say, the Starlite HTTPRoute , WebSocketRoute and Router classes do not extend their Starlette equivalents, but are rather independent implementations. It's important to note the following: Starlite Routers have a smaller api surface and do not expose decorators. Starlite Routers and Routes are not standalone ASGI apps and always depend upon a Starlite app instance. Starlite enforces a simple routing structure and doesn't support multiple-hosts and complex mounts. The reason for this decision is to enforce a simple routing pattern. It's true that this eliminates certain possibilities, for example - you cannot re-use paths based on different \"Host\" headers, as you can in Starlette, but this is intentional and is meant to enforce best practices.","title":"Routers and Controllers"},{"location":"usage/1-routers-and-controllers/#routers-and-controllers","text":"In most cases an API is composed of multiple endpoints, often with different sub-paths. Starlite offers two class components that make this simple to achieve - Router and Controller .","title":"Routers and Controllers"},{"location":"usage/1-routers-and-controllers/#controllers","text":"Controllers are subclasses of the Starlite Controller class that are used to organize endpoints under a specific sub-path. You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The distinct advantage of using controllers is that they allow both code sharing using OOP techniques and make the code better organized by promoting concern based code splitting. my_app/orders/controllers/user_order_controller.py from pydantic import UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial from my_app.orders.models import UserOrder class UserOrderController ( Controller ): path = \"/user\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ]) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> UserOrder : ... The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller, while retrieve_user_order has the path /user/{order_id:uuid}\" . Note You do not have to declare a path variable, yet if the path variable is missing or is an empty string, it will default to the root path of \"/\". Aside from the path class variable, you can also set the following optional class variables: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . before_request : a sync or async function to execute before a Request is passed to a route handler (method) on the controller. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : a sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object.","title":"Controllers"},{"location":"usage/1-routers-and-controllers/#routers","text":"my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) The Starlite Router class is used to organize sub-paths under a common namespace. In the above, it registers two different controllers, and each controller's respective path is combined with the router's path. Assuming that the UserOrderController defines a path of \"/user\" and PartnerOrderController defines a path of \" /partner\", their paths will be \"/orders/user\" and \"orders/partner\" respectively. Aside from path and route_handlers which are required kwargs, you can also pass the following kwargs to Router: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . before_request : a sync or async function to execute before a Request is passed to a route handler (function or controller method) on the router. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : a sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object.","title":"Routers"},{"location":"usage/1-routers-and-controllers/#registering-routes","text":"At the root of every Starlite application there is an instance of Starlite, on which the root level controllers, routers and/or router-handlers are registered, for example: my_app/main.py from starlite import get , Starlite from users import UserController from orders import order_router @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check , UserController , order_router ]) The root level components registered on the app have whatever path is defined on them without anything appended to it. Thus, the health_check function above is available on \"/\" and the methods of UserController are available on \" /users\". To handle more complex path schemas you should use routers, which can register Controllers, individual functions but also other routers: my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) Once order_router is registered on base_router , the controllers registered on it will be respectively available on: \"/base/orders/user\" and \"/base/order/partner\" respectively. Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.","title":"Registering Routes"},{"location":"usage/1-routers-and-controllers/#registering-controllers-multiple-times","text":"Unlike routers, which can only be registered once, the same controller can be registered on different routers: my_app/users/router.py from starlite import Router from my_app.user.controllers import UserController internal_router = Router ( path = \"/internal\" , route_handlers = [ UserController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ UserController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ UserController ]) In the above, the same UserController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore , in the above example, three different instance of UserController will be created, each mounted on a different sub-path, e.g. \"/internal/users\", \"/partner/users\" and \"/consumer/users\".","title":"Registering Controllers Multiple Times"},{"location":"usage/1-routers-and-controllers/#registering-standalone-route-handlers-multiple-times","text":"You can also register standalone route handler handlers multiple times: my_app/users/router.py from starlite import Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) This is possible because the route handler is copied when registered. Thus, each router has its own unique instance of the route handler rather than the same one. Path behaviour is identical to controllers, namely, the route handler function will be accessible in the following paths: \"/internal/handler\", \"/partner/handler\" and \"/consumer/handler\".","title":"Registering Standalone Route Handlers Multiple Times"},{"location":"usage/1-routers-and-controllers/#relation-to-starlette-routing","text":"Although Starlite uses the Starlette ASGI toolkit, Starlite does not extend or use the Starlette routing system as is. That is to say, the Starlite HTTPRoute , WebSocketRoute and Router classes do not extend their Starlette equivalents, but are rather independent implementations. It's important to note the following: Starlite Routers have a smaller api surface and do not expose decorators. Starlite Routers and Routes are not standalone ASGI apps and always depend upon a Starlite app instance. Starlite enforces a simple routing structure and doesn't support multiple-hosts and complex mounts. The reason for this decision is to enforce a simple routing pattern. It's true that this eliminates certain possibilities, for example - you cannot re-use paths based on different \"Host\" headers, as you can in Starlette, but this is intentional and is meant to enforce best practices.","title":"Relation to Starlette Routing"},{"location":"usage/10-plugins/","text":"Plugins You can extend Starlite to support non-pydantic / dataclass types using plugins. Using plugins, you can have Starlite parse and validate inbound values (e.g. request-body data or parameters) as if they were pydantic models, and then serialize the data into the desired model type, or list thereof. Plugins also allow you to return an instance or list of instances of a model, and have it serialized correctly. Builtin Plugins Currently, Starlite includes a single plugin starlite.plugins.sql_alchemy.SQLAlchemyPlugin , with other plugins being planned / discussed - see the pinned issues in github for the current state of these. SQLAlchemyPlugin To use the SQLAlchemyPlugin simply import it and pass it to the Starlite constructor: my_app/main.py from starlite import Starlite from starlite.plugins.sql_alchemy import SQLAlchemyPlugin app = Starlite ( route_handlers = [ ... ], plugins = [ SQLAlchemyPlugin ()]) Note The SQLAlchemyPlugin will not create a DB connection, a sessionmaker or anything of this kind. This you will need to implement on your own according to the pattern of your choice, or using a 3rd party solution of some sort. The reason for this is that SQL Alchemy is very flexible and allows you to interact with it in various ways. We cannot decide upon the pattern that will fit your architecture in advance, and hence it is left to the user to decide. You can now use SQL alchemy declarative classes as route handler parameters or return values: my_app/company/models/company.py from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) my_app/company/endpoints.py from starlite import post , get from my_app.company.models import Company @post ( path = \"/companies\" ) def create_company ( data : Company ) -> Company : ... @get ( path = \"/companies\" ) def get_companies () -> List [ Company ]: ... Important The SQLAlchemyPlugin supports only declarative style classes, it does not support the older imperative style because this style does not use classes, and is very hard to convert to pydantic correctly. Handling of Relationships The SQL Alchemy plugin handles relationship by traversing and recursively converting the related tables into pydantic models. This approach, while powerful, poses some difficulties. For example, consider these two tables: from sqlalchemy import Column , Float , ForeignKey , Integer , String from sqlalchemy.orm import relationship , declarative_base Base = declarative_base () class Pet ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) age = Column ( Float ) owner_id = Column ( Integer , ForeignKey ( \"user.id\" )) owner = relationship ( \"User\" , back_populates = \"pets\" ) class User ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String , default = \"moishe\" ) pets = relationship ( \"Pet\" , back_populates = \"owner\" , ) The User table references the Pet table, which back references the User table. Hence, the resulting pydantic model will include a circular reference. To avoid this, the plugin sets relationships of this kind in the pydantic model type Any with a default of None . This means you can provide any value for them - or none at all, and validation will not break. Additionally, all relationships are defined as Optional in the pydantic model, following the assumption you might not send complete data structures using the API. Creating Plugins A plugin is a class the implements the starlite.plugins.base.PluginProtocol class, which expects a generic T representing the model type to be used. To create a plugin you must implement the following methods: def to_pydantic_model_class ( self , model_class : Type [ T ], ** kwargs : Any ) -> Type [ BaseModel ]: \"\"\" Given a model_class T, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : Type [ T ], pydantic_model_instance : BaseModel ) -> T : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : T ) -> Dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : Type [ T ], ** kwargs : Any ) -> T : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ...","title":"Plugins"},{"location":"usage/10-plugins/#plugins","text":"You can extend Starlite to support non-pydantic / dataclass types using plugins. Using plugins, you can have Starlite parse and validate inbound values (e.g. request-body data or parameters) as if they were pydantic models, and then serialize the data into the desired model type, or list thereof. Plugins also allow you to return an instance or list of instances of a model, and have it serialized correctly.","title":"Plugins"},{"location":"usage/10-plugins/#builtin-plugins","text":"Currently, Starlite includes a single plugin starlite.plugins.sql_alchemy.SQLAlchemyPlugin , with other plugins being planned / discussed - see the pinned issues in github for the current state of these.","title":"Builtin Plugins"},{"location":"usage/10-plugins/#sqlalchemyplugin","text":"To use the SQLAlchemyPlugin simply import it and pass it to the Starlite constructor: my_app/main.py from starlite import Starlite from starlite.plugins.sql_alchemy import SQLAlchemyPlugin app = Starlite ( route_handlers = [ ... ], plugins = [ SQLAlchemyPlugin ()]) Note The SQLAlchemyPlugin will not create a DB connection, a sessionmaker or anything of this kind. This you will need to implement on your own according to the pattern of your choice, or using a 3rd party solution of some sort. The reason for this is that SQL Alchemy is very flexible and allows you to interact with it in various ways. We cannot decide upon the pattern that will fit your architecture in advance, and hence it is left to the user to decide. You can now use SQL alchemy declarative classes as route handler parameters or return values: my_app/company/models/company.py from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) my_app/company/endpoints.py from starlite import post , get from my_app.company.models import Company @post ( path = \"/companies\" ) def create_company ( data : Company ) -> Company : ... @get ( path = \"/companies\" ) def get_companies () -> List [ Company ]: ... Important The SQLAlchemyPlugin supports only declarative style classes, it does not support the older imperative style because this style does not use classes, and is very hard to convert to pydantic correctly.","title":"SQLAlchemyPlugin"},{"location":"usage/10-plugins/#handling-of-relationships","text":"The SQL Alchemy plugin handles relationship by traversing and recursively converting the related tables into pydantic models. This approach, while powerful, poses some difficulties. For example, consider these two tables: from sqlalchemy import Column , Float , ForeignKey , Integer , String from sqlalchemy.orm import relationship , declarative_base Base = declarative_base () class Pet ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) age = Column ( Float ) owner_id = Column ( Integer , ForeignKey ( \"user.id\" )) owner = relationship ( \"User\" , back_populates = \"pets\" ) class User ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String , default = \"moishe\" ) pets = relationship ( \"Pet\" , back_populates = \"owner\" , ) The User table references the Pet table, which back references the User table. Hence, the resulting pydantic model will include a circular reference. To avoid this, the plugin sets relationships of this kind in the pydantic model type Any with a default of None . This means you can provide any value for them - or none at all, and validation will not break. Additionally, all relationships are defined as Optional in the pydantic model, following the assumption you might not send complete data structures using the API.","title":"Handling of Relationships"},{"location":"usage/10-plugins/#creating-plugins","text":"A plugin is a class the implements the starlite.plugins.base.PluginProtocol class, which expects a generic T representing the model type to be used. To create a plugin you must implement the following methods: def to_pydantic_model_class ( self , model_class : Type [ T ], ** kwargs : Any ) -> Type [ BaseModel ]: \"\"\" Given a model_class T, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : Type [ T ], pydantic_model_instance : BaseModel ) -> T : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : T ) -> Dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : Type [ T ], ** kwargs : Any ) -> T : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ...","title":"Creating Plugins"},{"location":"usage/11-data-transfer-objects/","text":"Data Transfer Objects (DTOs) Starlite includes a DTOFactory class that allows you to create DTOs from pydantic models, dataclasses and any other class supported via plugins. An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields. The created DTO can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model. Important Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as DTO[T] , with T being a generic argument representing the original model used to create the DTO. Note MyPy doesn't support using types defined using Type[] as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment. The DTOFactory class supports plugins , for example, this is how it could be used with an SQL Alchemy declarative class: from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) The created CompanyDTO is equal to this pydantic model declaration: from pydantic import BaseModel class CompanyDTO ( BaseModel ): id : int name : str worth : float You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future. Excluding Fields You can exclude any field in the original model class from the DTO: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , exclude = [ \"first\" ]) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int Remapping Fields You can remap fields in two ways: you can switch change their keys: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , remap = { \"first\" : \"third\" }) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int third : int You can remap name and type. To do this use a tuple instead of a string for the object value: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , remap = { \"first\" : \"third\" , \"second\" : ( \"fourth\" , float )} ) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): third : int fourth : float Add New Fields You add fields that do not exist in the original model by passing in a field_defintions dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper : For required fields use a tuple of type + ellipsis, for example (str, ...) . For optional fields use a tuple of type + None , for example (str, None) To set a default value use a tuple of type + default value, for example (str, \"Hello World\") from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_definitions = { \"third\" : ( str , ... )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): first : int second : int third : str DTO Methods from_model_instance Once you create a DTO class you can use its class method from_model_instance to create an instance from an existing instance of the model from which the DTO was generated: from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) company_instance = Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 ) dto_instance = CompanyDTO . from_model_instance ( company_instance ) In the above, dto_instance is a validated pydantic model instance. to_model_instance When you have an instance of a DTO model, you can convert it into a model instance using the to_model_instance method: from starlite import get def create_company ( data : CompanyDTO ) -> Company : company_instance = data . to_model_instance () ... In the above company_instance is an instance of the SQL Alchemy class Company . It is correctly typed as Company because the DTO class uses generic to store this data. Important If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised.","title":"Data Transfer Objects (DTOs)"},{"location":"usage/11-data-transfer-objects/#data-transfer-objects-dtos","text":"Starlite includes a DTOFactory class that allows you to create DTOs from pydantic models, dataclasses and any other class supported via plugins. An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields. The created DTO can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model. Important Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as DTO[T] , with T being a generic argument representing the original model used to create the DTO. Note MyPy doesn't support using types defined using Type[] as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment. The DTOFactory class supports plugins , for example, this is how it could be used with an SQL Alchemy declarative class: from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) The created CompanyDTO is equal to this pydantic model declaration: from pydantic import BaseModel class CompanyDTO ( BaseModel ): id : int name : str worth : float You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future.","title":"Data Transfer Objects (DTOs)"},{"location":"usage/11-data-transfer-objects/#excluding-fields","text":"You can exclude any field in the original model class from the DTO: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , exclude = [ \"first\" ]) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int","title":"Excluding Fields"},{"location":"usage/11-data-transfer-objects/#remapping-fields","text":"You can remap fields in two ways: you can switch change their keys: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , remap = { \"first\" : \"third\" }) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int third : int You can remap name and type. To do this use a tuple instead of a string for the object value: from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , remap = { \"first\" : \"third\" , \"second\" : ( \"fourth\" , float )} ) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): third : int fourth : float","title":"Remapping Fields"},{"location":"usage/11-data-transfer-objects/#add-new-fields","text":"You add fields that do not exist in the original model by passing in a field_defintions dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper : For required fields use a tuple of type + ellipsis, for example (str, ...) . For optional fields use a tuple of type + None , for example (str, None) To set a default value use a tuple of type + default value, for example (str, \"Hello World\") from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_definitions = { \"third\" : ( str , ... )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): first : int second : int third : str","title":"Add New Fields"},{"location":"usage/11-data-transfer-objects/#dto-methods","text":"","title":"DTO Methods"},{"location":"usage/11-data-transfer-objects/#from_model_instance","text":"Once you create a DTO class you can use its class method from_model_instance to create an instance from an existing instance of the model from which the DTO was generated: from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): id = Column ( Integer , primary_key = True ) name = Column ( String ) worth = Column ( Float ) CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) company_instance = Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 ) dto_instance = CompanyDTO . from_model_instance ( company_instance ) In the above, dto_instance is a validated pydantic model instance.","title":"from_model_instance"},{"location":"usage/11-data-transfer-objects/#to_model_instance","text":"When you have an instance of a DTO model, you can convert it into a model instance using the to_model_instance method: from starlite import get def create_company ( data : CompanyDTO ) -> Company : company_instance = data . to_model_instance () ... In the above company_instance is an instance of the SQL Alchemy class Company . It is correctly typed as Company because the DTO class uses generic to store this data. Important If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised.","title":"to_model_instance"},{"location":"usage/12-openapi/","text":"OpenAPI Starlite has first class OpenAPI support offering the following features: extensive OpenAPI 3.1.0 spec generation integrated Redoc UI Spec Generation Spec Generation utilizes the excellent openapi-schema-pydantic library, which offers a complete implementation of the OpenAPI specs as pydantic models. Starlite generates OpenAPI specs version 3.1.0 - the latest version of the specification . App Level Configuration OpenAPI schema generation is enabled by default. To configure it you can pass an instance of starlite.config.OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required kwargs, you can pass the following optional kwargs: create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . contact : An instance of the Contact model. description : Description text. external_docs : An instance of the ExternalDocumentation model. license : An instance of the License model. security : An instance of the SecurityRequirement model. servers : A list of Server model instances. defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag model instances. terms_of_service : A url to a page containing the terms of service. webhooks : A string keyed dictionary of PathItem model instances. Note All models listed above are exported from openapi-schema-pydantic rather than Starlite. Viewing the API Documentation in ReDoc Starlite comes with integration of ReDoc API Documentation Page to render your OpenAPI schema as an interactive web user interace. If your app is running locally on port 8000 you can access the ReDoc page at http://0.0.0.0:8000/schema . The ReDoc page will show and document all your routes, DTOs, and any metadata attached to your controllers mentioned above. Disable Schema Generation If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = None ) Route Handler Configuration By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema to False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also affect the schema by enriching and/or modifying it using the following kwargs: tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function). Accessing the OpenAPI Schema The generated schema is an instance of the OpenAPI pydantic model, and you can access it in any route handler like so: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> None : schema = request . app . openapi_schema ... The OpenAPI Controller Starlite includes a pre-configured controller called OpenAPIController which exposes three endpoints: /schema/openapi.yaml , allowing for download of the OpenAPI schema as YAML, using the application/vnd.oai.openapi Content-Type. /schema/openapi.json , allowing for download of the OpenAPI schema as JSON, using the application/vnd.oai.openapi+json Content-Type. /schema , which serves a Redoc UI static website for the OpenAPI docs. Important prior to version 0.3.0 there was only a single download endpoint by default and its path was /schema prior to version 0.8.0, the redoc UI was found at /schema/redoc and has since been moved to /schema for ease of use. If you would like to modify the endpoints, add new endpoints, change the styling of redoc etc., you can subclass the OpenAPIController and then pass your subclass to the OpenAPIConfig . For example, lets say we wanted to change the base path from \"/schema\" to \"/api-docs\": my_app/openapi.py from starlite import OpenAPIController class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" We would then use the subclassed controller like so: from starlite import Starlite , OpenAPIConfig from my_app.openapi import MyOpenAPIController app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( openapI_controller = MyOpenAPIController ), )","title":"OpenAPI"},{"location":"usage/12-openapi/#openapi","text":"Starlite has first class OpenAPI support offering the following features: extensive OpenAPI 3.1.0 spec generation integrated Redoc UI","title":"OpenAPI"},{"location":"usage/12-openapi/#spec-generation","text":"Spec Generation utilizes the excellent openapi-schema-pydantic library, which offers a complete implementation of the OpenAPI specs as pydantic models. Starlite generates OpenAPI specs version 3.1.0 - the latest version of the specification .","title":"Spec Generation"},{"location":"usage/12-openapi/#app-level-configuration","text":"OpenAPI schema generation is enabled by default. To configure it you can pass an instance of starlite.config.OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required kwargs, you can pass the following optional kwargs: create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . contact : An instance of the Contact model. description : Description text. external_docs : An instance of the ExternalDocumentation model. license : An instance of the License model. security : An instance of the SecurityRequirement model. servers : A list of Server model instances. defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag model instances. terms_of_service : A url to a page containing the terms of service. webhooks : A string keyed dictionary of PathItem model instances. Note All models listed above are exported from openapi-schema-pydantic rather than Starlite.","title":"App Level Configuration"},{"location":"usage/12-openapi/#viewing-the-api-documentation-in-redoc","text":"Starlite comes with integration of ReDoc API Documentation Page to render your OpenAPI schema as an interactive web user interace. If your app is running locally on port 8000 you can access the ReDoc page at http://0.0.0.0:8000/schema . The ReDoc page will show and document all your routes, DTOs, and any metadata attached to your controllers mentioned above.","title":"Viewing the API Documentation in ReDoc"},{"location":"usage/12-openapi/#disable-schema-generation","text":"If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = None )","title":"Disable Schema Generation"},{"location":"usage/12-openapi/#route-handler-configuration","text":"By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema to False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also affect the schema by enriching and/or modifying it using the following kwargs: tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function).","title":"Route Handler Configuration"},{"location":"usage/12-openapi/#accessing-the-openapi-schema","text":"The generated schema is an instance of the OpenAPI pydantic model, and you can access it in any route handler like so: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> None : schema = request . app . openapi_schema ...","title":"Accessing the OpenAPI Schema"},{"location":"usage/12-openapi/#the-openapi-controller","text":"Starlite includes a pre-configured controller called OpenAPIController which exposes three endpoints: /schema/openapi.yaml , allowing for download of the OpenAPI schema as YAML, using the application/vnd.oai.openapi Content-Type. /schema/openapi.json , allowing for download of the OpenAPI schema as JSON, using the application/vnd.oai.openapi+json Content-Type. /schema , which serves a Redoc UI static website for the OpenAPI docs. Important prior to version 0.3.0 there was only a single download endpoint by default and its path was /schema prior to version 0.8.0, the redoc UI was found at /schema/redoc and has since been moved to /schema for ease of use. If you would like to modify the endpoints, add new endpoints, change the styling of redoc etc., you can subclass the OpenAPIController and then pass your subclass to the OpenAPIConfig . For example, lets say we wanted to change the base path from \"/schema\" to \"/api-docs\": my_app/openapi.py from starlite import OpenAPIController class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" We would then use the subclassed controller like so: from starlite import Starlite , OpenAPIConfig from my_app.openapi import MyOpenAPIController app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( openapI_controller = MyOpenAPIController ), )","title":"The OpenAPI Controller"},{"location":"usage/13-request-lifecycle-hooks/","text":"Request Life Cycle Hooks Starlite borrows the concept of before_request and after_request hooks from Flask. These are general purpose hooks that allow the user to execute a function before the request is processed by the route handler, potentially bypassing the route handler completely, and after the route handler returns - modifying or even replacing the response. The primary use case for these hooks is to perform side effects, such as opening DB connections, start celery tasks etc., or to perform operations such as caching of responses. Before Request The before request handler is a sync or async function that receives the starlite.connection.Request instance before it reaches the route handler function. It does not have to return a value, but if it does return a value other than None , then the route handler will not be called and this value will instead be used for the response. from starlite import Starlite , Request async def my_before_request_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], before_request = my_before_request_handler ) After Request The after request handler is a sync or async function that receives the Response object - this can be either an instance of starlite.response.Response or any subclass of the Starlette Response object, and returning a Response object. from starlite import Starlite , Response async def my_after_request_handler ( response : Response ) -> Response : ... app = Starlite ( route_handlers = [ ... ], after_request = my_after_request_handler ) Overriding Handlers You can configure a before_request and after_request handlers on each layer of your application - the starlite application, on routers, controllers or individual route handlers. Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level. from starlite import Starlite , Router , Controller , get # this overrides the router and app class MyController ( Controller ): path = \"/my-path\" # this overrides the controller, router and app @get ( after_request =... , before_request =... ) def my_handler ( self ) -> None : ... # this overrides the app, for all routes below the router these functions will be used router = Router ( route_handlers = [ MyController ], after_request =... , before_request =... ) # this is top level app = Starlite ( route_handlers = [ router ], after_request =... , before_request =... )","title":"Request Life Cycle Hooks"},{"location":"usage/13-request-lifecycle-hooks/#request-life-cycle-hooks","text":"Starlite borrows the concept of before_request and after_request hooks from Flask. These are general purpose hooks that allow the user to execute a function before the request is processed by the route handler, potentially bypassing the route handler completely, and after the route handler returns - modifying or even replacing the response. The primary use case for these hooks is to perform side effects, such as opening DB connections, start celery tasks etc., or to perform operations such as caching of responses.","title":"Request Life Cycle Hooks"},{"location":"usage/13-request-lifecycle-hooks/#before-request","text":"The before request handler is a sync or async function that receives the starlite.connection.Request instance before it reaches the route handler function. It does not have to return a value, but if it does return a value other than None , then the route handler will not be called and this value will instead be used for the response. from starlite import Starlite , Request async def my_before_request_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], before_request = my_before_request_handler )","title":"Before Request"},{"location":"usage/13-request-lifecycle-hooks/#after-request","text":"The after request handler is a sync or async function that receives the Response object - this can be either an instance of starlite.response.Response or any subclass of the Starlette Response object, and returning a Response object. from starlite import Starlite , Response async def my_after_request_handler ( response : Response ) -> Response : ... app = Starlite ( route_handlers = [ ... ], after_request = my_after_request_handler )","title":"After Request"},{"location":"usage/13-request-lifecycle-hooks/#overriding-handlers","text":"You can configure a before_request and after_request handlers on each layer of your application - the starlite application, on routers, controllers or individual route handlers. Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level. from starlite import Starlite , Router , Controller , get # this overrides the router and app class MyController ( Controller ): path = \"/my-path\" # this overrides the controller, router and app @get ( after_request =... , before_request =... ) def my_handler ( self ) -> None : ... # this overrides the app, for all routes below the router these functions will be used router = Router ( route_handlers = [ MyController ], after_request =... , before_request =... ) # this is top level app = Starlite ( route_handlers = [ router ], after_request =... , before_request =... )","title":"Overriding Handlers"},{"location":"usage/14-testing/","text":"Testing Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box. Tip Starlite bundles the library pydantic-factories , which offers an easy and powerful way to generate mock data from pydantic models and dataclasses. Test Client Starlite extends the Starlette testing client, which in turn is built using the requests library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient from my_app.main import app def test_health_check (): with TestClient ( app = app ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient def test_health_check ( test_client : TestClient ): with test_client as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" !!! important use the test client as a context manager (i.e. with the with ) keyword if you want to use the starlite app's on_startup and on_shutdown . Creating a Testing App Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Create a Test Request Another helper is create_test_request , which creates an instance of starlite.connection.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException , HttpMethod , create_test_request from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = create_test_request ( http_method = HttpMethod . GET ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) Aside from http_method , which is required , you can pass the following optional kwargs to create_test_request : scheme : \"http\" or \"https\". Defaults to http . server : Server domain. Defaults to test.org . port : Request port. Defaults to 3000 . root_path : Root path. Defaults to / . path : Path. Defaults to empty string. query : A string keyed dictionary of query parameters - can contain lists. Defaults to None . headers : A string keyed dictionary of header parameters. Defaults to None . cookie : A string representing a cookie. Defaults to None . content : A dictionary or a pydantic model that forms the request body. Defaults to None . request_media_type : Media type of the request, defaults to RequestEncodingType.JSON . app : An instance of Starlite to set as request.app . Defaults to None .","title":"Testing"},{"location":"usage/14-testing/#testing","text":"Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box. Tip Starlite bundles the library pydantic-factories , which offers an easy and powerful way to generate mock data from pydantic models and dataclasses.","title":"Testing"},{"location":"usage/14-testing/#test-client","text":"Starlite extends the Starlette testing client, which in turn is built using the requests library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient from my_app.main import app def test_health_check (): with TestClient ( app = app ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient def test_health_check ( test_client : TestClient ): with test_client as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" !!! important use the test client as a context manager (i.e. with the with ) keyword if you want to use the starlite app's on_startup and on_shutdown .","title":"Test Client"},{"location":"usage/14-testing/#creating-a-testing-app","text":"Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Creating a Testing App"},{"location":"usage/14-testing/#create-a-test-request","text":"Another helper is create_test_request , which creates an instance of starlite.connection.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException , HttpMethod , create_test_request from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = create_test_request ( http_method = HttpMethod . GET ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) Aside from http_method , which is required , you can pass the following optional kwargs to create_test_request : scheme : \"http\" or \"https\". Defaults to http . server : Server domain. Defaults to test.org . port : Request port. Defaults to 3000 . root_path : Root path. Defaults to / . path : Path. Defaults to empty string. query : A string keyed dictionary of query parameters - can contain lists. Defaults to None . headers : A string keyed dictionary of header parameters. Defaults to None . cookie : A string representing a cookie. Defaults to None . content : A dictionary or a pydantic model that forms the request body. Defaults to None . request_media_type : Media type of the request, defaults to RequestEncodingType.JSON . app : An instance of Starlite to set as request.app . Defaults to None .","title":"Create a Test Request"},{"location":"usage/15-templating/","text":"Templating Starlite has built-in support for both jinja2 and mako as template engines, and it also offers a simple way to add additional template engines. Registering a Template Engine To register one of the built-in template engines you simply need to pass it to the Starlite constructor: from starlite import TemplateConfig , Starlite from starlite.template.jinja import JinjaTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Or from starlite import TemplateConfig , Starlite from starlite.template.mako import MakoTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ), ) The kwarg directory passed to TemplateConfig is either a directory or list of directories to use for loading templates. Template Responses Once you have a template engine registered you can use it in route handlers: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) The name kwarg passed to the Template class is the filename for the given template. Starlite will search all the directories specifies for this file until it finds it or an exception will be raised. The context kwarg is a dictionary specifing context data that is passed to the engine. Defining a Custom Template Engine If you wish to use another templating engine, you can easily do so by implemnting starlite.template.TemplateEngineProtocol . This class accepts a generic argument T which should be the template class, and it specifies two methods: class TemplateEngineProtocol ( Protocol [ T ]): def __init__ ( self , directory : Union [ DirectoryPath , List [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , name : str ) -> T : \"\"\"Loads the template with name and returns it.\"\"\" ... Once you have your custom engine you can regiter it as you would the built-in engines.","title":"Templating"},{"location":"usage/15-templating/#templating","text":"Starlite has built-in support for both jinja2 and mako as template engines, and it also offers a simple way to add additional template engines.","title":"Templating"},{"location":"usage/15-templating/#registering-a-template-engine","text":"To register one of the built-in template engines you simply need to pass it to the Starlite constructor: from starlite import TemplateConfig , Starlite from starlite.template.jinja import JinjaTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Or from starlite import TemplateConfig , Starlite from starlite.template.mako import MakoTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ), ) The kwarg directory passed to TemplateConfig is either a directory or list of directories to use for loading templates.","title":"Registering a Template Engine"},{"location":"usage/15-templating/#template-responses","text":"Once you have a template engine registered you can use it in route handlers: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) The name kwarg passed to the Template class is the filename for the given template. Starlite will search all the directories specifies for this file until it finds it or an exception will be raised. The context kwarg is a dictionary specifing context data that is passed to the engine.","title":"Template Responses"},{"location":"usage/15-templating/#defining-a-custom-template-engine","text":"If you wish to use another templating engine, you can easily do so by implemnting starlite.template.TemplateEngineProtocol . This class accepts a generic argument T which should be the template class, and it specifies two methods: class TemplateEngineProtocol ( Protocol [ T ]): def __init__ ( self , directory : Union [ DirectoryPath , List [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , name : str ) -> T : \"\"\"Loads the template with name and returns it.\"\"\" ... Once you have your custom engine you can regiter it as you would the built-in engines.","title":"Defining a Custom Template Engine"},{"location":"usage/16-caching/","text":"Response Caching Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching: from starlite import get @get ( \"/cached-path\" , cache = True ) def my_cached_handler () -> str : ... By setting cache=True in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified. Alternatively you can specify the number of seconds to cache the responses from the given handler like so: from starlite import get @get ( \"/cached-path\" , cache = 120 ) # seconds def my_cached_handler () -> str : ... Specifying a Cache Key Builder Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys: from starlite import Request , get def my_custom_key_builder ( request : Request ) -> str : return request . url . path + request . headers . get ( \"my-header\" , \"\" ) @get ( \"/cached-path\" , cache = True , cache_key_builder = my_custom_key_builder ) def my_cached_handler () -> str : ... You can also specify the default cache key builder to use for the entire application (see below). Configuring Caching You can configure caching behaviour on the application level by passing an instance of CacheConfig to the Starlite constructor. CacheConfig accepts 3 optional kwargs: backend : the cache backend to use. Defaults to an instance of starlite.cache.SimpleCacheBackend . expiration : the default expiration. Defaults to 60 seconds. cache_key_builder : the default key builder function. As mentioned above, the default key builder uses the request.url.path + its sorted query parameters. Registering a Cache Backend Starlite comes with a single builtin cache backend called SimpleCacheBackend , which stores values in memory using a dictionary. This is fine for local development but is not a production grade solution. In a production environment its probably a good idea to use a more robust solution for caching - using a database, disk storage, or an external service such as Redis , Memcached or Etcd . To do this you simply need to either implement the starlite.cache.CacheBackendProtocol , or provide an object that fulfills it. For example, you can directly use all 3 libraries mentioned above without needing to implement anything. To use Redis as an example: from redis import Redis from starlite import CacheConfig redis = Redis ( host = \"localhost\" , port = 6379 , db = 0 ) cache_config = CacheConfig ( backend = redis )","title":"Response Caching"},{"location":"usage/16-caching/#response-caching","text":"Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching: from starlite import get @get ( \"/cached-path\" , cache = True ) def my_cached_handler () -> str : ... By setting cache=True in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified. Alternatively you can specify the number of seconds to cache the responses from the given handler like so: from starlite import get @get ( \"/cached-path\" , cache = 120 ) # seconds def my_cached_handler () -> str : ...","title":"Response Caching"},{"location":"usage/16-caching/#specifying-a-cache-key-builder","text":"Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys: from starlite import Request , get def my_custom_key_builder ( request : Request ) -> str : return request . url . path + request . headers . get ( \"my-header\" , \"\" ) @get ( \"/cached-path\" , cache = True , cache_key_builder = my_custom_key_builder ) def my_cached_handler () -> str : ... You can also specify the default cache key builder to use for the entire application (see below).","title":"Specifying a Cache Key Builder"},{"location":"usage/16-caching/#configuring-caching","text":"You can configure caching behaviour on the application level by passing an instance of CacheConfig to the Starlite constructor. CacheConfig accepts 3 optional kwargs: backend : the cache backend to use. Defaults to an instance of starlite.cache.SimpleCacheBackend . expiration : the default expiration. Defaults to 60 seconds. cache_key_builder : the default key builder function. As mentioned above, the default key builder uses the request.url.path + its sorted query parameters.","title":"Configuring Caching"},{"location":"usage/16-caching/#registering-a-cache-backend","text":"Starlite comes with a single builtin cache backend called SimpleCacheBackend , which stores values in memory using a dictionary. This is fine for local development but is not a production grade solution. In a production environment its probably a good idea to use a more robust solution for caching - using a database, disk storage, or an external service such as Redis , Memcached or Etcd . To do this you simply need to either implement the starlite.cache.CacheBackendProtocol , or provide an object that fulfills it. For example, you can directly use all 3 libraries mentioned above without needing to implement anything. To use Redis as an example: from redis import Redis from starlite import CacheConfig redis = Redis ( host = \"localhost\" , port = 6379 , db = 0 ) cache_config = CacheConfig ( backend = redis )","title":"Registering a Cache Backend"},{"location":"usage/3-parameters/","text":"Parameters Path Parameters from starlite import get from my_app.models import User @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : ... In the above there are two components: The path parameter is defined inside the path kwarg passed to the @get decorator in the form {parameter_name:parameter_type} . This definition of the path parameter is based on the Starlette path parameter mechanism. Yet, in difference to Starlette, which allows defining path parameters without defining their types, Starlite enforces this typing, with the following types supported: int , float , str , uuid . The get_user function defines a parameter with the same name as defined in the path kwarg. This ensures that the value of the path parameter will be injected into the function when it's called. The types do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: from datetime import datetime from typing import List from starlite import get from my_app.models import Order @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> List [ Order ]: ... The parameter defined inside the path kwarg is typed as int , because the value passed from the frontend will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, its fine to omit it. It will still be validated and added to the openapi schema correctly. Extra Validation and Documentation for Path Params If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from openapi_schema_pydantic import Example from starlite import get , Parameter from my_app.models import Version @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific specification version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = \"https://mywebsite.com/documentation/product#versions\" , ) ) -> Version : ... In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema. Query Parameters To define query parameters simply define them as kwargs in your function declaration: from datetime import datetime from typing import List , Optional from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], page_size : int = 10 , from_date : Optional [ datetime ] = None , to_date : Optional [ datetime ] = None , ) -> List [ Order ]: ... The above is a rather classic example of a paginated \"GET\" request: page is a required query parameter of type int . It has no default value and as such has to be provided or a ValidationException will be raised. page_size is a required query parameter of type int as well, but it has a default value - so it can be omitted in the request. brands is an optional list of strings with a default None value. from_date and to_date are optional date-time values that have a default None value. These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. This works great, but what happens when the request is sent with a non-python naming scheme, such as camelCase ? You could of course simply rename your variables accordingly: from datetime import datetime from typing import Optional , List from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], pageSize : int = 10 , fromDate : Optional [ datetime ] = None , toDate : Optional [ datetime ] = None , ) -> List [ Order ]: ... This doesn't look so good, and tools such as PyLint will complain. The solution here is to use the Parameter function : from datetime import datetime from typing import Optional , List from starlite import get , Parameter from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , page_size : int = Parameter ( query = \"pageSize\" , gt = 0 , le = 100 ), brands : List [ str ] = Parameter ( min_items = 2 , max_items = 5 ), from_Date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), to_date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), ) -> List [ Order ]: ... As you can see, specifying the \"query\" kwarg allows us to remap from one key to another. Furthermore, we can use Parameter for extended validation and documentation, as is done for page_size . Header and Cookie Parameters Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , token : str = Parameter ( header = \"X-API-KEY\" ), ) -> User : ... OR from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , cookie : str = Parameter ( cookie = \"my-cookie-param\" ), ) -> User : ... As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters. The Parameter Function Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. Parameter accepts the following optional kwargs: header : The header parameter key for this parameter. A value for this kwarg is required for header parameters. cookie : The cookie parameter key for this parameter. A value for this kwarg is required for cookie parameters. query : The query parameter key for this parameter. examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . required : A boolean flag dictating whether this parameter is required. If set to False , None values will be allowed. Defaults to True . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.","title":"Parameters"},{"location":"usage/3-parameters/#parameters","text":"","title":"Parameters"},{"location":"usage/3-parameters/#path-parameters","text":"from starlite import get from my_app.models import User @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : ... In the above there are two components: The path parameter is defined inside the path kwarg passed to the @get decorator in the form {parameter_name:parameter_type} . This definition of the path parameter is based on the Starlette path parameter mechanism. Yet, in difference to Starlette, which allows defining path parameters without defining their types, Starlite enforces this typing, with the following types supported: int , float , str , uuid . The get_user function defines a parameter with the same name as defined in the path kwarg. This ensures that the value of the path parameter will be injected into the function when it's called. The types do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: from datetime import datetime from typing import List from starlite import get from my_app.models import Order @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> List [ Order ]: ... The parameter defined inside the path kwarg is typed as int , because the value passed from the frontend will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, its fine to omit it. It will still be validated and added to the openapi schema correctly.","title":"Path Parameters"},{"location":"usage/3-parameters/#extra-validation-and-documentation-for-path-params","text":"If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from openapi_schema_pydantic import Example from starlite import get , Parameter from my_app.models import Version @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific specification version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = \"https://mywebsite.com/documentation/product#versions\" , ) ) -> Version : ... In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema.","title":"Extra Validation and Documentation for Path Params"},{"location":"usage/3-parameters/#query-parameters","text":"To define query parameters simply define them as kwargs in your function declaration: from datetime import datetime from typing import List , Optional from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], page_size : int = 10 , from_date : Optional [ datetime ] = None , to_date : Optional [ datetime ] = None , ) -> List [ Order ]: ... The above is a rather classic example of a paginated \"GET\" request: page is a required query parameter of type int . It has no default value and as such has to be provided or a ValidationException will be raised. page_size is a required query parameter of type int as well, but it has a default value - so it can be omitted in the request. brands is an optional list of strings with a default None value. from_date and to_date are optional date-time values that have a default None value. These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. This works great, but what happens when the request is sent with a non-python naming scheme, such as camelCase ? You could of course simply rename your variables accordingly: from datetime import datetime from typing import Optional , List from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], pageSize : int = 10 , fromDate : Optional [ datetime ] = None , toDate : Optional [ datetime ] = None , ) -> List [ Order ]: ... This doesn't look so good, and tools such as PyLint will complain. The solution here is to use the Parameter function : from datetime import datetime from typing import Optional , List from starlite import get , Parameter from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , page_size : int = Parameter ( query = \"pageSize\" , gt = 0 , le = 100 ), brands : List [ str ] = Parameter ( min_items = 2 , max_items = 5 ), from_Date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), to_date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), ) -> List [ Order ]: ... As you can see, specifying the \"query\" kwarg allows us to remap from one key to another. Furthermore, we can use Parameter for extended validation and documentation, as is done for page_size .","title":"Query Parameters"},{"location":"usage/3-parameters/#header-and-cookie-parameters","text":"Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , token : str = Parameter ( header = \"X-API-KEY\" ), ) -> User : ... OR from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , cookie : str = Parameter ( cookie = \"my-cookie-param\" ), ) -> User : ... As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters.","title":"Header and Cookie Parameters"},{"location":"usage/3-parameters/#the-parameter-function","text":"Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. Parameter accepts the following optional kwargs: header : The header parameter key for this parameter. A value for this kwarg is required for header parameters. cookie : The cookie parameter key for this parameter. A value for this kwarg is required for cookie parameters. query : The query parameter key for this parameter. examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . required : A boolean flag dictating whether this parameter is required. If set to False , None values will be allowed. Defaults to True . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.","title":"The Parameter Function"},{"location":"usage/4-request-body/","text":"Request Body For all http requests, except GET requests, you can access the request body by specifying the data kwarg in your handler function or method: from starlite import post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... Because User in the above example is a pydantic model you get the benefit of validation and a decent schema generation out of the box. The Body Function For extended validation and supplying schema data, use the Body function: from starlite import Body , post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ) ) -> User : ... The Body function is very similar to the Parameter function , and it receives the following kwargs: media_type : An instance of the starlite.enums.RequestEncodingType enum. Defaults to RequestEncodingType.JSON . examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. URL Encoded Form Data To access url encoded form data, i.e. data sent with an application/x-www-form-urlencoded Content-Type header, you need to use Body and specify RequestEncodingType.URL_ENCODED as the media_type kwarg: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : ... The above ensures that Starlite will inject data using the request.form() method rather than request.json(). It also causes the generated OpenAPI schema to use the correct media type. Important url encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures, e.g. frontend forms. MultiPart Form Data Multipart formdata supports complex formdata including file uploads. You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : ... Accessing Files In case of files uploaded, Starlette transforms the results into an instance of starlette.datastructures.UploadFile , which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... To access multiple files with known filenames, you can use a pydantic model: my_app/models.py from pydantic import BaseModel from starlette.datastructures import UploadFile class FormData ( BaseModel ): cv : UploadFile image : UploadFile class Config : arbitrary_types_allowed = True from starlite import Body , post , RequestEncodingType from my_app.models import FormData @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... If you do not care about parsing and validation and only want to access the form data as a dictionary, you can do this: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import Dict @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : Dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ) ) -> None : ... Finally, if you do not know the filenames are do not care about them, you can get the files as a list: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import List @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : List [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ...","title":"Request Body"},{"location":"usage/4-request-body/#request-body","text":"For all http requests, except GET requests, you can access the request body by specifying the data kwarg in your handler function or method: from starlite import post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... Because User in the above example is a pydantic model you get the benefit of validation and a decent schema generation out of the box.","title":"Request Body"},{"location":"usage/4-request-body/#the-body-function","text":"For extended validation and supplying schema data, use the Body function: from starlite import Body , post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ) ) -> User : ... The Body function is very similar to the Parameter function , and it receives the following kwargs: media_type : An instance of the starlite.enums.RequestEncodingType enum. Defaults to RequestEncodingType.JSON . examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.","title":"The Body Function"},{"location":"usage/4-request-body/#url-encoded-form-data","text":"To access url encoded form data, i.e. data sent with an application/x-www-form-urlencoded Content-Type header, you need to use Body and specify RequestEncodingType.URL_ENCODED as the media_type kwarg: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : ... The above ensures that Starlite will inject data using the request.form() method rather than request.json(). It also causes the generated OpenAPI schema to use the correct media type. Important url encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures, e.g. frontend forms.","title":"URL Encoded Form Data"},{"location":"usage/4-request-body/#multipart-form-data","text":"Multipart formdata supports complex formdata including file uploads. You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : ...","title":"MultiPart Form Data"},{"location":"usage/4-request-body/#accessing-files","text":"In case of files uploaded, Starlette transforms the results into an instance of starlette.datastructures.UploadFile , which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... To access multiple files with known filenames, you can use a pydantic model: my_app/models.py from pydantic import BaseModel from starlette.datastructures import UploadFile class FormData ( BaseModel ): cv : UploadFile image : UploadFile class Config : arbitrary_types_allowed = True from starlite import Body , post , RequestEncodingType from my_app.models import FormData @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... If you do not care about parsing and validation and only want to access the form data as a dictionary, you can do this: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import Dict @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : Dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ) ) -> None : ... Finally, if you do not know the filenames are do not care about them, you can get the files as a list: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import List @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : List [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ...","title":"Accessing Files"},{"location":"usage/5-responses/","text":"Responses When you return a value from a route handler function, Starlite takes the value and passes it to the constructor of the Starlite Response class ( starlite.response.Response ), as the response's content kwarg. It also sets the response's status_code and media_type kwargs based on either what was defined in the route handler decorator or default values. For example, lets assume we have a model named Resource which we persist using some orm abstracted into a repository: my_api/models/resource.py from pydantic import BaseModel class Resource ( BaseModel ): id : int name : str We have a route handler that takes a resource_id kwarg, passed as a path parameter, which is then used to retrieve the persisted resource from the DB: from starlite import get from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" ) async def retrieve_resource ( resource_id : int ) -> Resource : return await ResourceRepository . find ( id = resource_id ) Once the retrieve_resource handler returns, Starlite will use the return value to create a Response instance. The status_code of the response will be HTTP_200_OK , which is the default for GET, and a media_type of MediaType.JSON , which is the default media type. As a result the return value, which is a pydantic model, will be serialized into JSON, and the response's Content-Type header will be set to \"application/json\". Status Codes You can specify a status_code to set for the response as a decorator kwarg: from starlite import get from starlette.status import HTTP_202_ACCEPTED from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" , status_code = HTTP_202_ACCEPTED ) async def retrieve_resource ( resource_id : int ) -> Resource : resource = await ResourceRepository . find ( id = resource_id ) return resource Setting the status_code kwarg is optional for delete , get , patch , post and put decorators, and also for the route decorators when only setting a single http_method . If not set by the user, the following defaults will be used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Note When using the route decorator with multiple http methods, the default status code is 200 . Also note that the default for delete is no content because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can write integers as the value for status_code , e.g. status_code=200 , its best practice to use constants (also in tests). Starlette includes easy to use statuses that are exported from starlette.status , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the standard library documentation . Media Type As previously mentioned, the default media type is MediaType.JSON , which translates into a response with the \"Content-Type\" header of application/json . MediaType here is a Starlite enum ( starlite.enums.MediaType ) which is used for convenience - you can pass a string value as well but should ensure that it is a legitimate value according to the receiver / OpenAPI specs. This enum has 3 members, each correlating with a specific Content-Type header: MediaType.JSON: application/json MediaType.TEXT: text/plain MediaType.HTML: text/html The return value of the handler should correlate with the media_type of the function (see below). Text Responses For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" HTML Responses For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string. JSON Responses As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models numpy ndarray lists containing any of the above elements Since Starlite uses the excellent (and super-fast!) orjson library to handle JSON (also in requests), you can use the following values as part of your responses without issue: all UUIDs datetime classes numpy primitives and objects (see orjson docs ) If you need to return other values and would like to extend serialization you can do this using Custom Responses . Response Types Not all responses can be inferred using the media_type kwarg, and for these types of responses Starlite relies on special wrapper classes. Redirect Responses Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import get from starlite.datastructures import Redirect @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path File Responses File responses send a file: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) Streaming Responses To return a streaming response use the Stream class: from asyncio import sleep from starlite import get from starlite.datastructures import Stream from datetime import datetime from orjson import dumps async def my_iterator () -> bytes : while True : await sleep ( 0.01 ) yield dumps ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_iterator ) The Stream class receives a single required kwarg - iterator , which should be either a sync or an async iterator. Using Custom Responses You can use a subclass of starlite.responses.Response and specify it as the response class using the response_class kwarg. For example, lets say we want to handle subclasses of Document from the elasticsearch_dsl package as shown below: from elasticsearch_dsl import Document , Integer , Keyword class MyDocument ( Document ): name = Keyword () level = Integer () type = Keyword () It would be best if we had a generic response class that was able to handle all Document subclasses. Luckily, the Document model already comes with a to_dict method, which makes our lives a bit simpler: from typing import Any , Dict from elasticsearch_dsl import Document from starlite import Response class DocumentResponse ( Response ): def serializer ( self , value : Any ) -> Dict [ str , Any ]: if isinstance ( value , Document ): return value . to_dict () return super () . serializer ( value ) We can now use this in our route handler: from elasticsearch_dsl import Document from starlite import get from my_app.responses import DocumentResponse @get ( path = \"/document\" , response_class = DocumentResponse ) def get_document () -> Document : ... You can specify the response class to use at all levels of your application. On specific route handlers, on a controller, a router even on the app instance itself: from starlite import Controller , Starlite , Router from my_app.responses import DocumentResponse # controller class MyController ( Controller ): path = \"...\" response_class = DocumentResponse # router my_router = Router ( path = \"...\" , route_handlers = [ ... ], response_class = DocumentResponse ) # app my_app = Starlite ( route_handlers = [ ... ], response_class = DocumentResponse ) When you specify a response_class in multiple places, the closest layer to the response handler will take precedence. That is, the response_class specified on the route handler takes precedence over the one specified on the controller or router, which will in turn take precedence over the one specified on the app level. You can therefore easily override response classes as needed. Returning Responses Directly You can return an instance of any Starlette response, including the Starlite Response and subclasses thereof from a route handler function: from starlite import get from starlette.responses import Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) OR from starlite import get , Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) Important If you return a response directly the OpenAPI schema generation will not be able to properly annotate the response. Response Headers To add headers to a response use the ResponseHeader model: from starlite import ResponseHeader , get @get ( path = \"/\" , response_headers = { \"my-header\" : ResponseHeader ( value = \"secret\" , description = \"super secret header\" ) }, ) def my_route_handler () -> None : ... You can declare response headers on all layers of the app - individual route handlers, controllers, routers and the app itself. This works like dependencies - that is, lower levels override higher levels.","title":"Responses"},{"location":"usage/5-responses/#responses","text":"When you return a value from a route handler function, Starlite takes the value and passes it to the constructor of the Starlite Response class ( starlite.response.Response ), as the response's content kwarg. It also sets the response's status_code and media_type kwargs based on either what was defined in the route handler decorator or default values. For example, lets assume we have a model named Resource which we persist using some orm abstracted into a repository: my_api/models/resource.py from pydantic import BaseModel class Resource ( BaseModel ): id : int name : str We have a route handler that takes a resource_id kwarg, passed as a path parameter, which is then used to retrieve the persisted resource from the DB: from starlite import get from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" ) async def retrieve_resource ( resource_id : int ) -> Resource : return await ResourceRepository . find ( id = resource_id ) Once the retrieve_resource handler returns, Starlite will use the return value to create a Response instance. The status_code of the response will be HTTP_200_OK , which is the default for GET, and a media_type of MediaType.JSON , which is the default media type. As a result the return value, which is a pydantic model, will be serialized into JSON, and the response's Content-Type header will be set to \"application/json\".","title":"Responses"},{"location":"usage/5-responses/#status-codes","text":"You can specify a status_code to set for the response as a decorator kwarg: from starlite import get from starlette.status import HTTP_202_ACCEPTED from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" , status_code = HTTP_202_ACCEPTED ) async def retrieve_resource ( resource_id : int ) -> Resource : resource = await ResourceRepository . find ( id = resource_id ) return resource Setting the status_code kwarg is optional for delete , get , patch , post and put decorators, and also for the route decorators when only setting a single http_method . If not set by the user, the following defaults will be used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Note When using the route decorator with multiple http methods, the default status code is 200 . Also note that the default for delete is no content because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can write integers as the value for status_code , e.g. status_code=200 , its best practice to use constants (also in tests). Starlette includes easy to use statuses that are exported from starlette.status , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the standard library documentation .","title":"Status Codes"},{"location":"usage/5-responses/#media-type","text":"As previously mentioned, the default media type is MediaType.JSON , which translates into a response with the \"Content-Type\" header of application/json . MediaType here is a Starlite enum ( starlite.enums.MediaType ) which is used for convenience - you can pass a string value as well but should ensure that it is a legitimate value according to the receiver / OpenAPI specs. This enum has 3 members, each correlating with a specific Content-Type header: MediaType.JSON: application/json MediaType.TEXT: text/plain MediaType.HTML: text/html The return value of the handler should correlate with the media_type of the function (see below).","title":"Media Type"},{"location":"usage/5-responses/#text-responses","text":"For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\"","title":"Text Responses"},{"location":"usage/5-responses/#html-responses","text":"For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.","title":"HTML Responses"},{"location":"usage/5-responses/#json-responses","text":"As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models numpy ndarray lists containing any of the above elements Since Starlite uses the excellent (and super-fast!) orjson library to handle JSON (also in requests), you can use the following values as part of your responses without issue: all UUIDs datetime classes numpy primitives and objects (see orjson docs ) If you need to return other values and would like to extend serialization you can do this using Custom Responses .","title":"JSON Responses"},{"location":"usage/5-responses/#response-types","text":"Not all responses can be inferred using the media_type kwarg, and for these types of responses Starlite relies on special wrapper classes.","title":"Response Types"},{"location":"usage/5-responses/#redirect-responses","text":"Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import get from starlite.datastructures import Redirect @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path","title":"Redirect Responses"},{"location":"usage/5-responses/#file-responses","text":"File responses send a file: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import get from starlite.datastructures import File @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , )","title":"File Responses"},{"location":"usage/5-responses/#streaming-responses","text":"To return a streaming response use the Stream class: from asyncio import sleep from starlite import get from starlite.datastructures import Stream from datetime import datetime from orjson import dumps async def my_iterator () -> bytes : while True : await sleep ( 0.01 ) yield dumps ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_iterator ) The Stream class receives a single required kwarg - iterator , which should be either a sync or an async iterator.","title":"Streaming Responses"},{"location":"usage/5-responses/#using-custom-responses","text":"You can use a subclass of starlite.responses.Response and specify it as the response class using the response_class kwarg. For example, lets say we want to handle subclasses of Document from the elasticsearch_dsl package as shown below: from elasticsearch_dsl import Document , Integer , Keyword class MyDocument ( Document ): name = Keyword () level = Integer () type = Keyword () It would be best if we had a generic response class that was able to handle all Document subclasses. Luckily, the Document model already comes with a to_dict method, which makes our lives a bit simpler: from typing import Any , Dict from elasticsearch_dsl import Document from starlite import Response class DocumentResponse ( Response ): def serializer ( self , value : Any ) -> Dict [ str , Any ]: if isinstance ( value , Document ): return value . to_dict () return super () . serializer ( value ) We can now use this in our route handler: from elasticsearch_dsl import Document from starlite import get from my_app.responses import DocumentResponse @get ( path = \"/document\" , response_class = DocumentResponse ) def get_document () -> Document : ... You can specify the response class to use at all levels of your application. On specific route handlers, on a controller, a router even on the app instance itself: from starlite import Controller , Starlite , Router from my_app.responses import DocumentResponse # controller class MyController ( Controller ): path = \"...\" response_class = DocumentResponse # router my_router = Router ( path = \"...\" , route_handlers = [ ... ], response_class = DocumentResponse ) # app my_app = Starlite ( route_handlers = [ ... ], response_class = DocumentResponse ) When you specify a response_class in multiple places, the closest layer to the response handler will take precedence. That is, the response_class specified on the route handler takes precedence over the one specified on the controller or router, which will in turn take precedence over the one specified on the app level. You can therefore easily override response classes as needed.","title":"Using Custom Responses"},{"location":"usage/5-responses/#returning-responses-directly","text":"You can return an instance of any Starlette response, including the Starlite Response and subclasses thereof from a route handler function: from starlite import get from starlette.responses import Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) OR from starlite import get , Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) Important If you return a response directly the OpenAPI schema generation will not be able to properly annotate the response.","title":"Returning Responses Directly"},{"location":"usage/5-responses/#response-headers","text":"To add headers to a response use the ResponseHeader model: from starlite import ResponseHeader , get @get ( path = \"/\" , response_headers = { \"my-header\" : ResponseHeader ( value = \"secret\" , description = \"super secret header\" ) }, ) def my_route_handler () -> None : ... You can declare response headers on all layers of the app - individual route handlers, controllers, routers and the app itself. This works like dependencies - that is, lower levels override higher levels.","title":"Response Headers"},{"location":"usage/6-dependency-injection/","text":"Dependency Injection Starlite has a simple but powerful dependency injection system. To explain how it works lets begin with 4 different functions, each returning a different kind of value: def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... We can declare dependencies on different levels of the application using the Provide class: from starlite import Controller , Router , Starlite , Provide , get from my_app.dependencies import bool_fn , dict_fn , int_fn , list_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) In the above example, the route handler function my_route_handler has four different dependencies injected into it as kwargs. Pre-requisites and Scope The pre-requisites for dependency injection are these: dependencies must be callables (sync or async). dependencies can receive kwargs and a self arg but not positional args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers. Dependency Kwargs As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers except other dependencies. Let's say we have a model called Wallet , which we'll assume we persist in a DB: my_app/models.py from pydantic import BaseModel , UUID4 class Wallet ( BaseModel ): id : UUID4 currency : str value : float We have a WalletController class with basic CRUD route handlers: my_app/wallet/controller.py from starlite import Controller , Partial , delete , get , patch , post from my_app.models import Wallet class WalletController ( Controller ): path = \"/wallet\" @post () async def create_wallet ( self , data : Wallet ) -> Wallet : ... @get ( path = \"/{wallet_id:uuid}\" ) async def retrieve_wallet ( self , wallet : Wallet ) -> Wallet : ... @patch ( path = \"/{wallet_id:uuid}\" ) async def update_wallet ( self , data : Partial [ Wallet ], wallet : Wallet ) -> Wallet : ... @delete ( path = \"/{wallet_id:uuid}\" ) async def delete_wallet ( self , wallet : Wallet ) -> None : ... We need to inject the wallet instance into the retrieve_wallet , update_wallet and delete_wallet routes. To do this we will create a dependency that takes a wallet_id kwarg and then retrieves the instance from the DB: my_app/dependencies.py from pydantic import UUID4 from my_app.models import Wallet async def get_wallet_by_id ( wallet_id : UUID4 ) -> Wallet : ... We will now set it on the controller with the correct keyword: my_app/wallet/controller.py from starlite import Controller , Provide from my_app.dependencies import get_wallet_by_id class WalletController ( Controller ): path = \"/wallet\" dependencies = { \"wallet\" : Provide ( get_wallet_by_id ) } # ... This is it - since the controller methods declared the correct path parameter, this value will be passed into the get_wallet_by_id . Overriding Dependencies Because dependencies are declared at each level using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get from my_app.dependencies import bool_fn , dict_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... As you can see in the above - the lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one. This logic applies on all layers. The Provide Class Provide is a simple wrapper that takes a callable as a required arg, and an optional kwarg - use_cache . By default Provide will not cache the return value of the dependency, and it will be executed on every call to the route handler that uses it. If use_cache is True , it will cache the return value on the first execution and will not call it again. Important The caching done inside Provide is very simple - it stores the return value and returns it. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option. Using Dependencies in Dependencies You can inject dependencies into other dependencies - exactly like you would into regular functions. For example, lets consider a scenario where we want to inject a DB connection into a dependency. Our top level dependency will look something like this: my_app/postgres.py from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite.datastructures import State from app.config import settings def get_postgres_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" if not hasattr ( state , \"postgres_connection\" ): state . postgres_connection = create_async_engine ( settings . DATABASE_URI ) return cast ( AsyncEngine , state . postgres_connection ) We will place it as a the top level dependency: from starlite import Starlite , Provide from my_app.postgres import get_postgres_connection app = Starlite ( route_handlers = [ ... ], dependencies = { \"connection\" : Provide ( get_postgres_connection )} ) We can now use this dependency in other dependencies: my_app/dependencies.py from pydantic import UUID4 from sqlalchemy.ext.asyncio import AsyncEngine from my_app.models import Wallet async def get_wallet_by_id ( connection : AsyncEngine , wallet_id : UUID4 ) -> Wallet : ...","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/#dependency-injection","text":"Starlite has a simple but powerful dependency injection system. To explain how it works lets begin with 4 different functions, each returning a different kind of value: def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... We can declare dependencies on different levels of the application using the Provide class: from starlite import Controller , Router , Starlite , Provide , get from my_app.dependencies import bool_fn , dict_fn , int_fn , list_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) In the above example, the route handler function my_route_handler has four different dependencies injected into it as kwargs.","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/#pre-requisites-and-scope","text":"The pre-requisites for dependency injection are these: dependencies must be callables (sync or async). dependencies can receive kwargs and a self arg but not positional args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers.","title":"Pre-requisites and Scope"},{"location":"usage/6-dependency-injection/#dependency-kwargs","text":"As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers except other dependencies. Let's say we have a model called Wallet , which we'll assume we persist in a DB: my_app/models.py from pydantic import BaseModel , UUID4 class Wallet ( BaseModel ): id : UUID4 currency : str value : float We have a WalletController class with basic CRUD route handlers: my_app/wallet/controller.py from starlite import Controller , Partial , delete , get , patch , post from my_app.models import Wallet class WalletController ( Controller ): path = \"/wallet\" @post () async def create_wallet ( self , data : Wallet ) -> Wallet : ... @get ( path = \"/{wallet_id:uuid}\" ) async def retrieve_wallet ( self , wallet : Wallet ) -> Wallet : ... @patch ( path = \"/{wallet_id:uuid}\" ) async def update_wallet ( self , data : Partial [ Wallet ], wallet : Wallet ) -> Wallet : ... @delete ( path = \"/{wallet_id:uuid}\" ) async def delete_wallet ( self , wallet : Wallet ) -> None : ... We need to inject the wallet instance into the retrieve_wallet , update_wallet and delete_wallet routes. To do this we will create a dependency that takes a wallet_id kwarg and then retrieves the instance from the DB: my_app/dependencies.py from pydantic import UUID4 from my_app.models import Wallet async def get_wallet_by_id ( wallet_id : UUID4 ) -> Wallet : ... We will now set it on the controller with the correct keyword: my_app/wallet/controller.py from starlite import Controller , Provide from my_app.dependencies import get_wallet_by_id class WalletController ( Controller ): path = \"/wallet\" dependencies = { \"wallet\" : Provide ( get_wallet_by_id ) } # ... This is it - since the controller methods declared the correct path parameter, this value will be passed into the get_wallet_by_id .","title":"Dependency Kwargs"},{"location":"usage/6-dependency-injection/#overriding-dependencies","text":"Because dependencies are declared at each level using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get from my_app.dependencies import bool_fn , dict_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... As you can see in the above - the lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one. This logic applies on all layers.","title":"Overriding Dependencies"},{"location":"usage/6-dependency-injection/#the-provide-class","text":"Provide is a simple wrapper that takes a callable as a required arg, and an optional kwarg - use_cache . By default Provide will not cache the return value of the dependency, and it will be executed on every call to the route handler that uses it. If use_cache is True , it will cache the return value on the first execution and will not call it again. Important The caching done inside Provide is very simple - it stores the return value and returns it. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option.","title":"The Provide Class"},{"location":"usage/6-dependency-injection/#using-dependencies-in-dependencies","text":"You can inject dependencies into other dependencies - exactly like you would into regular functions. For example, lets consider a scenario where we want to inject a DB connection into a dependency. Our top level dependency will look something like this: my_app/postgres.py from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite.datastructures import State from app.config import settings def get_postgres_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" if not hasattr ( state , \"postgres_connection\" ): state . postgres_connection = create_async_engine ( settings . DATABASE_URI ) return cast ( AsyncEngine , state . postgres_connection ) We will place it as a the top level dependency: from starlite import Starlite , Provide from my_app.postgres import get_postgres_connection app = Starlite ( route_handlers = [ ... ], dependencies = { \"connection\" : Provide ( get_postgres_connection )} ) We can now use this dependency in other dependencies: my_app/dependencies.py from pydantic import UUID4 from sqlalchemy.ext.asyncio import AsyncEngine from my_app.models import Wallet async def get_wallet_by_id ( connection : AsyncEngine , wallet_id : UUID4 ) -> Wallet : ...","title":"Using Dependencies in Dependencies"},{"location":"usage/7-middleware/","text":"Middleware Middlewares are mini ASGI apps that receive the raw request object and validate or transform it in some manner. Middlewares are useful when you need to operate on all incoming requests on the app level. Starlite builds on top of the Starlette middleware architecture and is 100% compatible with it - and any 3rd party middlewares created for it. The Middleware Protocol You can build your own middleware by either subclassing the starlette.middleware.base.BaseHTTPMiddleware class (see the starlette documentation), or by creating a class that implements the Starlite MiddlewareProtocol . For example, lets create a simple middleware that does some naive logging for every request: import logging from starlette.types import ASGIApp , Receive , Scope , Send from starlite import MiddlewareProtocol , Request logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) What's happening above? The __init__ method receives and sets \"app\" - app is not an instance of Starlite, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. It's important to note here two things: Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope dictionary, not any ephemeral request objects created as in the above. Once the middleware finishes doing whatever its doing, it should pass scope , receive and send to either self.app or an instance of Response - this is equivalent in other middleware architectures to calling next , which is what happens in the last line of the example. Built-in Middlewares Starlette includes several builtin middlewares - you can see the list in the Starlette docs. Of these middlewares, Starlite offers a simple way to use two of them: CORS CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of starlite.config.CORSConfig to the Starlite constructor: from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) You can pass the following kwargs to CORSConfig: allow_origins : list of domain schemas, defaults to [\"*\"] allow_methods : list of http methods, defaults to [\"*\"] allow_headers : list of header keys, defaults to [\"*\"] allow_credentials : A boolean dictating whether CORS should support cookies in cross-origin requests. Defaults to False . allow_origin_regex : A regex string that is matches against incoming request origins. Defaults to None . expose_headers : A list of response headers to expose. Defaults to [] . max_age : Sets a response header instructing the max amount of seconds that the browser should cache a CORS response. Defaults to 600. Note The asterisks symbol in the above kwargs means \"match any\". You can read more about this middleware in the starlette docs . Trusted Hosts Another common security mechanism is to require that each incoming request has a \"HOST\" header, and then to restrict hosts to a specific set of domains - whats called \"allowed hosts\". To enable this middleware simply pass a list of trusted hosts to the Starlite constructor: from starlite import Starlite app = Starlite ( request_handlers = [ ... ], allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ) You can use * to match any subdomains, as in the above.","title":"Middleware"},{"location":"usage/7-middleware/#middleware","text":"Middlewares are mini ASGI apps that receive the raw request object and validate or transform it in some manner. Middlewares are useful when you need to operate on all incoming requests on the app level. Starlite builds on top of the Starlette middleware architecture and is 100% compatible with it - and any 3rd party middlewares created for it.","title":"Middleware"},{"location":"usage/7-middleware/#the-middleware-protocol","text":"You can build your own middleware by either subclassing the starlette.middleware.base.BaseHTTPMiddleware class (see the starlette documentation), or by creating a class that implements the Starlite MiddlewareProtocol . For example, lets create a simple middleware that does some naive logging for every request: import logging from starlette.types import ASGIApp , Receive , Scope , Send from starlite import MiddlewareProtocol , Request logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) What's happening above? The __init__ method receives and sets \"app\" - app is not an instance of Starlite, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. It's important to note here two things: Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope dictionary, not any ephemeral request objects created as in the above. Once the middleware finishes doing whatever its doing, it should pass scope , receive and send to either self.app or an instance of Response - this is equivalent in other middleware architectures to calling next , which is what happens in the last line of the example.","title":"The Middleware Protocol"},{"location":"usage/7-middleware/#built-in-middlewares","text":"Starlette includes several builtin middlewares - you can see the list in the Starlette docs. Of these middlewares, Starlite offers a simple way to use two of them:","title":"Built-in Middlewares"},{"location":"usage/7-middleware/#cors","text":"CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of starlite.config.CORSConfig to the Starlite constructor: from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) You can pass the following kwargs to CORSConfig: allow_origins : list of domain schemas, defaults to [\"*\"] allow_methods : list of http methods, defaults to [\"*\"] allow_headers : list of header keys, defaults to [\"*\"] allow_credentials : A boolean dictating whether CORS should support cookies in cross-origin requests. Defaults to False . allow_origin_regex : A regex string that is matches against incoming request origins. Defaults to None . expose_headers : A list of response headers to expose. Defaults to [] . max_age : Sets a response header instructing the max amount of seconds that the browser should cache a CORS response. Defaults to 600. Note The asterisks symbol in the above kwargs means \"match any\". You can read more about this middleware in the starlette docs .","title":"CORS"},{"location":"usage/7-middleware/#trusted-hosts","text":"Another common security mechanism is to require that each incoming request has a \"HOST\" header, and then to restrict hosts to a specific set of domains - whats called \"allowed hosts\". To enable this middleware simply pass a list of trusted hosts to the Starlite constructor: from starlite import Starlite app = Starlite ( request_handlers = [ ... ], allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ) You can use * to match any subdomains, as in the above.","title":"Trusted Hosts"},{"location":"usage/8-authentication/","text":"Authentication Starlite is agnostic as to what kind of authentication mechanism(s) an app should use - you can use cookies, JWT tokens, OpenID connect depending on your use-case. It also does not implement any of these mechanisms for you. What it does is offer an opinion as to where authentication should occur, namely - as part of your middleware stack. This is in accordance with Starlette and many other frameworks (e.g. Django, NestJS etc.). Authentication Middleware Starlite exports a class called AbstractAuthenticationMiddleware , which, as its name implies, is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app simply subclass AbstractAuthenticationMiddleware and implement the method authenticate_request , which has the following signature: from starlite import AuthenticationResult , Request async def authenticate_request ( request : Request ) -> AuthenticationResult : ... Example: Create a JWT Authentication Middleware For example, lets say we wanted to implement a JWT token based authentication. We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say its a pydantic model: import uuid from sqlalchemy import Column from sqlalchemy.dialects.postgresql import UUID from sqlalchemy.orm import declarative_base Base = declarative_base () class User ( Base ): id : uuid . UUID | None = Column ( UUID ( as_uuid = True ), default = uuid . uuid4 , primary_key = True ) # ... other fields follow, but we only require id for this example We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token: my_app/security/jwt.py from datetime import datetime , timedelta from uuid import UUID from jose import JWTError , jwt from pydantic import BaseModel , UUID4 from starlite.exceptions import NotAuthorizedException from app.config import settings DEFAULT_TIME_DELTA = timedelta ( days = 1 ) ALGORITHM = \"HS256\" class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 def decode_jwt_token ( encoded_token : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = settings . JWT_SECRET , algorithms = [ ALGORITHM ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e def encode_jwt_token ( user_id : UUID , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" token = Token ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( token . dict (), settings . JWT_SECRET , algorithm = ALGORITHM ) We can now create our authentication middleware: my_app/security/authentication_middleware.py from typing import cast from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncEngine , AsyncSession from starlette import HTTPConnection from starlite import AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException from app.db.models import User from app.security.jwt import decode_jwt_token API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , request : HTTPConnection ) -> AuthenticationResult : \"\"\" Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB \"\"\" # retrieve the auth header auth_header = request . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # decode the token, the result is a 'Token' model instance token = decode_jwt_token ( encoded_token = auth_header ) engine = cast ( AsyncEngine , request . app . state . postgres_connection ) async with AsyncSession ( engine ) as async_session : async with async_session . begin (): user = await async_session . execute ( select ( User ) . where ( User . id == token . sub )) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from my_app.security.authentication_middleware import JWTAuthenticationMiddleware app = Starlite ( request_handlers = [ ... ], middleware = [ JWTAuthenticationMiddleware ]) That's it. The JWTAuthenticationMiddleware will now run for every request. Authentication Result The method authenticate_request specified by AbstractAuthenticationMiddleware expects the return value to be an instance of AuthenticationResult . This is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively, for HTTP route handlers, and WebSocket.user and WebSocket.auth for websocket route handlers. Building on the previous example, we would be able to access these in an http route handler in the following way: from starlite import Request , get from my_app.db.models import User from my_app.security.jwt import Token @get ( \"/\" ) def my_route_handler ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token ... Or for a websocket route: from starlite import WebSocket , websocket from my_app.db.models import User from my_app.security.jwt import Token @websocket ( \"/\" ) async def my_route_handler ( socket : WebSocket [ User , Token ]) -> None : user = socket . user # correctly typed as User auth = socket . auth # correctly typed as Token ... And of course use the same kind of mechanism for dependencies: from typing import Any from starlite import Request , Provide , Router from my_app.db.models import User from my_app.security.jwt import Token async def my_dependency ( request : Request [ User , Token ]) -> Any : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token ... my_router = Router ( path = \"sub-path/\" , dependencies = { \"some_dependency\" : Provide ( my_dependency )} )","title":"Authentication"},{"location":"usage/8-authentication/#authentication","text":"Starlite is agnostic as to what kind of authentication mechanism(s) an app should use - you can use cookies, JWT tokens, OpenID connect depending on your use-case. It also does not implement any of these mechanisms for you. What it does is offer an opinion as to where authentication should occur, namely - as part of your middleware stack. This is in accordance with Starlette and many other frameworks (e.g. Django, NestJS etc.).","title":"Authentication"},{"location":"usage/8-authentication/#authentication-middleware","text":"Starlite exports a class called AbstractAuthenticationMiddleware , which, as its name implies, is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app simply subclass AbstractAuthenticationMiddleware and implement the method authenticate_request , which has the following signature: from starlite import AuthenticationResult , Request async def authenticate_request ( request : Request ) -> AuthenticationResult : ...","title":"Authentication Middleware"},{"location":"usage/8-authentication/#example-create-a-jwt-authentication-middleware","text":"For example, lets say we wanted to implement a JWT token based authentication. We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say its a pydantic model: import uuid from sqlalchemy import Column from sqlalchemy.dialects.postgresql import UUID from sqlalchemy.orm import declarative_base Base = declarative_base () class User ( Base ): id : uuid . UUID | None = Column ( UUID ( as_uuid = True ), default = uuid . uuid4 , primary_key = True ) # ... other fields follow, but we only require id for this example We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token: my_app/security/jwt.py from datetime import datetime , timedelta from uuid import UUID from jose import JWTError , jwt from pydantic import BaseModel , UUID4 from starlite.exceptions import NotAuthorizedException from app.config import settings DEFAULT_TIME_DELTA = timedelta ( days = 1 ) ALGORITHM = \"HS256\" class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 def decode_jwt_token ( encoded_token : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = settings . JWT_SECRET , algorithms = [ ALGORITHM ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e def encode_jwt_token ( user_id : UUID , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" token = Token ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( token . dict (), settings . JWT_SECRET , algorithm = ALGORITHM ) We can now create our authentication middleware: my_app/security/authentication_middleware.py from typing import cast from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncEngine , AsyncSession from starlette import HTTPConnection from starlite import AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException from app.db.models import User from app.security.jwt import decode_jwt_token API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , request : HTTPConnection ) -> AuthenticationResult : \"\"\" Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB \"\"\" # retrieve the auth header auth_header = request . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # decode the token, the result is a 'Token' model instance token = decode_jwt_token ( encoded_token = auth_header ) engine = cast ( AsyncEngine , request . app . state . postgres_connection ) async with AsyncSession ( engine ) as async_session : async with async_session . begin (): user = await async_session . execute ( select ( User ) . where ( User . id == token . sub )) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from my_app.security.authentication_middleware import JWTAuthenticationMiddleware app = Starlite ( request_handlers = [ ... ], middleware = [ JWTAuthenticationMiddleware ]) That's it. The JWTAuthenticationMiddleware will now run for every request.","title":"Example: Create a JWT Authentication Middleware"},{"location":"usage/8-authentication/#authentication-result","text":"The method authenticate_request specified by AbstractAuthenticationMiddleware expects the return value to be an instance of AuthenticationResult . This is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively, for HTTP route handlers, and WebSocket.user and WebSocket.auth for websocket route handlers. Building on the previous example, we would be able to access these in an http route handler in the following way: from starlite import Request , get from my_app.db.models import User from my_app.security.jwt import Token @get ( \"/\" ) def my_route_handler ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token ... Or for a websocket route: from starlite import WebSocket , websocket from my_app.db.models import User from my_app.security.jwt import Token @websocket ( \"/\" ) async def my_route_handler ( socket : WebSocket [ User , Token ]) -> None : user = socket . user # correctly typed as User auth = socket . auth # correctly typed as Token ... And of course use the same kind of mechanism for dependencies: from typing import Any from starlite import Request , Provide , Router from my_app.db.models import User from my_app.security.jwt import Token async def my_dependency ( request : Request [ User , Token ]) -> Any : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token ... my_router = Router ( path = \"sub-path/\" , dependencies = { \"some_dependency\" : Provide ( my_dependency )} )","title":"Authentication Result"},{"location":"usage/9-guards/","text":"Guards Guards are callables that receive two arguments - request , which is the Request instance, and route_handler , which is a copy of the RouteHandler model. Their role is to authorize the request by verifying that the request is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : my_app/enums.py from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: my_app/models.py from pydantic import BaseModel , UUID4 from my_app.enums import UserRole class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException from my_app.models import User def admin_user_guard ( request : Request [ User ], _ : RouteHandler ) -> None : if not request . user . is_admin : raise NotAuthorizedException () We can now use it, for example - lets say we have a route handler that allows users to create users: from starlite import post from my_app.guards import admin_user_guard from my_app.models import User @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler. Guard Scopes Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import Controller , Router , Starlite from my_app.guards import admin_user_guard # controller class UserController ( Controller ): path = \"/user\" guards = [ admin_user_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ admin_user_guard ] ) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ admin_user_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine. The Route Handler \"opt\" Key Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. To this end, all route handler decorators can receive the kwarg opt which adds a dictionary of arbitrary values to the route handler. For example: from starlite import get @get ( path = \"/\" , opt = { \"permissions\" : [ ... ]}) def my_route_handler () -> None : ... To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We can now use this in our endpoint of choice like so: from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"Guards"},{"location":"usage/9-guards/#guards","text":"Guards are callables that receive two arguments - request , which is the Request instance, and route_handler , which is a copy of the RouteHandler model. Their role is to authorize the request by verifying that the request is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : my_app/enums.py from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: my_app/models.py from pydantic import BaseModel , UUID4 from my_app.enums import UserRole class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException from my_app.models import User def admin_user_guard ( request : Request [ User ], _ : RouteHandler ) -> None : if not request . user . is_admin : raise NotAuthorizedException () We can now use it, for example - lets say we have a route handler that allows users to create users: from starlite import post from my_app.guards import admin_user_guard from my_app.models import User @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler.","title":"Guards"},{"location":"usage/9-guards/#guard-scopes","text":"Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import Controller , Router , Starlite from my_app.guards import admin_user_guard # controller class UserController ( Controller ): path = \"/user\" guards = [ admin_user_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ admin_user_guard ] ) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ admin_user_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine.","title":"Guard Scopes"},{"location":"usage/9-guards/#the-route-handler-opt-key","text":"Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. To this end, all route handler decorators can receive the kwarg opt which adds a dictionary of arbitrary values to the route handler. For example: from starlite import get @get ( path = \"/\" , opt = { \"permissions\" : [ ... ]}) def my_route_handler () -> None : ... To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We can now use this in our endpoint of choice like so: from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"The Route Handler \"opt\" Key"},{"location":"usage/2-route-handlers/0_route_handlers_concept/","text":"Route Handlers Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite. For example: from starlite import MediaType , get @get ( \"/\" , media_type = MediaType . TEXT ) def greet () -> str : return \"hello world\" In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path \"/\" and the http verb GET . In this case it will be a http response with a \"Content-Type\" header of text/plain . What the decorator does, is wrap the function or method within a class instance that inherits from starlite.handlers.base.BaseRouteHandler . These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation. Declaring Path(s) All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the path key word: from starlite import get @get ( path = \"/some-path\" ) def my_route_handler () -> None : ... It can also be passed as an argument without the key-word: from starlite import get @get ( \"/some-path\" ) def my_route_handler () -> None : ... And the value for this argument can be either a string path, as in the above examples, or a list of string paths: from starlite import get @get ([ \"/some-path\" , \"/some-other-path\" ]) def my_route_handler () -> None : ... This is particularly useful when you want to have optional path parameters : from starlite import get @get ( [ \"/some-path\" , \"/some-path/{some_id:int}\" ], ) def my_route_handler ( some_id : int = 1 ) -> None : ... Handler Function Kwargs Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters the request body dependencies Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally: state : injects a copy of the application state . headers : injects the request headers as an instance of starlette.datastructures.Headers - which is a case-insensitive mapping. query : injects the request query_params as a parsed dictionary. cookies : injects the request cookies as a parsed dictionary. As well as: request : injects the starlite.connection.Request instance. Available only for http route handlers socket : injects the starlite.connection.WebSocket instance. Available only for websocket handlers For example: from typing import Any , Dict from starlite import State , Request , get from starlette.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ... Tip You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite Handler Function Type Annotations Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an ImproperlyConfiguredException will be raised during the application bootup process. There are several reasons for why this limitation is enforeced: to ensure best practices to ensure consistent OpenAPI schema generation to allow Starlite to compute during the application bootstrap all the kwargs required by a function","title":"Route Handlers"},{"location":"usage/2-route-handlers/0_route_handlers_concept/#route-handlers","text":"Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite. For example: from starlite import MediaType , get @get ( \"/\" , media_type = MediaType . TEXT ) def greet () -> str : return \"hello world\" In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path \"/\" and the http verb GET . In this case it will be a http response with a \"Content-Type\" header of text/plain . What the decorator does, is wrap the function or method within a class instance that inherits from starlite.handlers.base.BaseRouteHandler . These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation.","title":"Route Handlers"},{"location":"usage/2-route-handlers/0_route_handlers_concept/#declaring-paths","text":"All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the path key word: from starlite import get @get ( path = \"/some-path\" ) def my_route_handler () -> None : ... It can also be passed as an argument without the key-word: from starlite import get @get ( \"/some-path\" ) def my_route_handler () -> None : ... And the value for this argument can be either a string path, as in the above examples, or a list of string paths: from starlite import get @get ([ \"/some-path\" , \"/some-other-path\" ]) def my_route_handler () -> None : ... This is particularly useful when you want to have optional path parameters : from starlite import get @get ( [ \"/some-path\" , \"/some-path/{some_id:int}\" ], ) def my_route_handler ( some_id : int = 1 ) -> None : ...","title":"Declaring Path(s)"},{"location":"usage/2-route-handlers/0_route_handlers_concept/#handler-function-kwargs","text":"Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters the request body dependencies Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally: state : injects a copy of the application state . headers : injects the request headers as an instance of starlette.datastructures.Headers - which is a case-insensitive mapping. query : injects the request query_params as a parsed dictionary. cookies : injects the request cookies as a parsed dictionary. As well as: request : injects the starlite.connection.Request instance. Available only for http route handlers socket : injects the starlite.connection.WebSocket instance. Available only for websocket handlers For example: from typing import Any , Dict from starlite import State , Request , get from starlette.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ... Tip You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite","title":"Handler Function Kwargs"},{"location":"usage/2-route-handlers/0_route_handlers_concept/#handler-function-type-annotations","text":"Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an ImproperlyConfiguredException will be raised during the application bootup process. There are several reasons for why this limitation is enforeced: to ensure best practices to ensure consistent OpenAPI schema generation to allow Starlite to compute during the application bootstrap all the kwargs required by a function","title":"Handler Function Type Annotations"},{"location":"usage/2-route-handlers/1_http_route_handlers/","text":"HTTP Route Handlers The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class starlite.handlers.http.HTTPRouteHandler , which is aliased as the decorator called route : from starlite import HttpMethod , route @route ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... As mentioned above, route does is merely an alias for HTTPRouteHandler , thus the below code is equivalent to the one above: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... HTTP Route Handlers Kwargs The route decorator requires an http_method kwarg, which is a member of the enum starlite.enums.HttpMethod or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . Additionally, you can pass the following optional kwargs: status_code : the status code for a success response. If not specified, a default value will be used . media_type : A string or a member of the enum starlite.enums.MediaType , which specifies the MIME Media Type for the response. Defaults to MediaType.JSON . See media-type . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . dependencies : A dictionary mapping dependency providers. See dependency-injection . opt : String keyed dictionary of arbitrary value that can be used by guards . guards : A list of guards . before_request : A sync or async function to execute before a Request is passed to the route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : A sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object. background_tasks : A callable wrapped in an instance of starlette.background.BackgroundTask or a sequence of BackgroundTask instances wrapped in starlette.background.BackgroundTasks . The callable(s) will be called after the response is executed. Note - if you return a value from a before_request hook, background tasks passed to the handler will not be executed. sync_to_thread : A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions . And the following kwargs, which affect OpenAPI schema generation include_in_schema : A boolean flag dictating whether the given route handler will appear in the generated OpenAPI schema. Defaults to True . tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. Semantic Handler Decorators Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from typing import List from starlite import Partial , delete , get , patch , post , put from my_app.models import Resource @get ( path = \"/resources\" ) def list_resources () -> List [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of starlite.handlers.http.HTTPRouteHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions. Using Sync Handler Functions You can use both sync and async functions as the base for route handler functions, but which should you use? and when? If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), he most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose. The reason for this is that async code, if written correctly, is non-blocking . That is, async code can be paused and resumed, and it therefore does not interupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking , and if you use such code in your function it can create performance issues. In this case you should use the sync_to_thread option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution. The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the sync_to_thread option.","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/1_http_route_handlers/#http-route-handlers","text":"The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class starlite.handlers.http.HTTPRouteHandler , which is aliased as the decorator called route : from starlite import HttpMethod , route @route ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... As mentioned above, route does is merely an alias for HTTPRouteHandler , thus the below code is equivalent to the one above: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ...","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/1_http_route_handlers/#http-route-handlers-kwargs","text":"The route decorator requires an http_method kwarg, which is a member of the enum starlite.enums.HttpMethod or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . Additionally, you can pass the following optional kwargs: status_code : the status code for a success response. If not specified, a default value will be used . media_type : A string or a member of the enum starlite.enums.MediaType , which specifies the MIME Media Type for the response. Defaults to MediaType.JSON . See media-type . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . dependencies : A dictionary mapping dependency providers. See dependency-injection . opt : String keyed dictionary of arbitrary value that can be used by guards . guards : A list of guards . before_request : A sync or async function to execute before a Request is passed to the route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_request : A sync or async function to execute before the Response is returned. This function receives the Respose object and it must return a Response object. background_tasks : A callable wrapped in an instance of starlette.background.BackgroundTask or a sequence of BackgroundTask instances wrapped in starlette.background.BackgroundTasks . The callable(s) will be called after the response is executed. Note - if you return a value from a before_request hook, background tasks passed to the handler will not be executed. sync_to_thread : A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions . And the following kwargs, which affect OpenAPI schema generation include_in_schema : A boolean flag dictating whether the given route handler will appear in the generated OpenAPI schema. Defaults to True . tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.","title":"HTTP Route Handlers Kwargs"},{"location":"usage/2-route-handlers/1_http_route_handlers/#semantic-handler-decorators","text":"Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from typing import List from starlite import Partial , delete , get , patch , post , put from my_app.models import Resource @get ( path = \"/resources\" ) def list_resources () -> List [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of starlite.handlers.http.HTTPRouteHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions.","title":"Semantic Handler Decorators"},{"location":"usage/2-route-handlers/1_http_route_handlers/#using-sync-handler-functions","text":"You can use both sync and async functions as the base for route handler functions, but which should you use? and when? If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), he most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose. The reason for this is that async code, if written correctly, is non-blocking . That is, async code can be paused and resumed, and it therefore does not interupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking , and if you use such code in your function it can create performance issues. In this case you should use the sync_to_thread option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution. The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the sync_to_thread option.","title":"Using Sync Handler Functions"},{"location":"usage/2-route-handlers/2_websocket_route_handlers/","text":"Websocket Route Handlers Starlite supports Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is an alias of the class starlite.handlers.websocket.WebsocketRouteHandler . Thus, the below code is equivalent to the one above: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. they must have a return annotation of None . they must be async functions. These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised. Note OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers. Websocket Route Handler Kwargs Aside from path , the asgi route handler accepts the following optional kwargs: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of guards . opt : String keyed dictionary of arbitrary value that can be used by guards .","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/2_websocket_route_handlers/#websocket-route-handlers","text":"Starlite supports Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is an alias of the class starlite.handlers.websocket.WebsocketRouteHandler . Thus, the below code is equivalent to the one above: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. they must have a return annotation of None . they must be async functions. These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised. Note OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers.","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/2_websocket_route_handlers/#websocket-route-handler-kwargs","text":"Aside from path , the asgi route handler accepts the following optional kwargs: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of guards . opt : String keyed dictionary of arbitrary value that can be used by guards .","title":"Websocket Route Handler Kwargs"},{"location":"usage/2-route-handlers/3_asgi_route_handlers/","text":"ASGI Route Handlers If you need to write your own ASGI application, you can do so using the asgi decorator: from starlette.types import Scope , Receive , Send from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import Response , asgi @asgi ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }, status_code = HTTP_200_OK ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send ) Like other route handlers, the asgi decorator is an alias of the class starlite.handlers.asgi.ASGIRouteHandler . Thus the code below is equivalent to the one above: from starlette.types import Scope , Receive , Send from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import ASGIRouteHandler , Response @ASGIRouteHandler ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }, status_code = HTTP_200_OK ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send ) Limitations of ASGI route handlers In difference to the other route handlers, the asgi route handler accepts only 3 kwargs that must be defined: scope , a mapping of values describing the asgi connection. It always includes a type key, with the values being either http or websocket , and a path key. If the type is http , the scope dictionary will also include a method key with the value being one of DELETE, GET, POST, PATCH, PUT, HEAD . receive , an injected function by which the ASGI application receives messages. send , an injected function by which the ASGI application sends messages. You can read more about these in the ASGI specification . Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised. ASGI Route Handler Kwargs Aside from path , the asgi route handler accepts the following optional kwargs: guards : A list of guards . opt : String keyed dictionary of arbitrary value that can be used by guards .","title":"ASGI Route Handlers"},{"location":"usage/2-route-handlers/3_asgi_route_handlers/#asgi-route-handlers","text":"If you need to write your own ASGI application, you can do so using the asgi decorator: from starlette.types import Scope , Receive , Send from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import Response , asgi @asgi ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }, status_code = HTTP_200_OK ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send ) Like other route handlers, the asgi decorator is an alias of the class starlite.handlers.asgi.ASGIRouteHandler . Thus the code below is equivalent to the one above: from starlette.types import Scope , Receive , Send from starlette.status import HTTP_200_OK , HTTP_400_BAD_REQUEST from starlite import ASGIRouteHandler , Response @ASGIRouteHandler ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }, status_code = HTTP_200_OK ) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send )","title":"ASGI Route Handlers"},{"location":"usage/2-route-handlers/3_asgi_route_handlers/#limitations-of-asgi-route-handlers","text":"In difference to the other route handlers, the asgi route handler accepts only 3 kwargs that must be defined: scope , a mapping of values describing the asgi connection. It always includes a type key, with the values being either http or websocket , and a path key. If the type is http , the scope dictionary will also include a method key with the value being one of DELETE, GET, POST, PATCH, PUT, HEAD . receive , an injected function by which the ASGI application receives messages. send , an injected function by which the ASGI application sends messages. You can read more about these in the ASGI specification . Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised.","title":"Limitations of ASGI route handlers"},{"location":"usage/2-route-handlers/3_asgi_route_handlers/#asgi-route-handler-kwargs","text":"Aside from path , the asgi route handler accepts the following optional kwargs: guards : A list of guards . opt : String keyed dictionary of arbitrary value that can be used by guards .","title":"ASGI Route Handler Kwargs"}]}